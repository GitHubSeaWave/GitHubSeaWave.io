[{"categories":["学习笔记"],"content":"Junit使用教程 ","date":"2022-03-30","objectID":"/index.zh_cn/:0:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"简介 单元测试工具（方法） 常用于白盒测试 ","date":"2022-03-30","objectID":"/index.zh_cn/:1:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"安装 创建一个普通Maven项目 在pom.xml中引入依赖 Maven \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 注：junit4.11以上版本不在包含hamcrest，需要手动安装 \u003c!-- https://mvnrepository.com/artifact/org.hamcrest/hamcrest-core --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.hamcrest\u003c/groupId\u003e \u003cartifactId\u003ehamcrest-core\u003c/artifactId\u003e \u003cversion\u003e1.3\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e ","date":"2022-03-30","objectID":"/index.zh_cn/:2:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"覆盖测试 ","date":"2022-03-30","objectID":"/index.zh_cn/:3:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"条件覆盖 @Test public void test1(){ System.out.println(getData(6, 12)); //R==\u003e6^2*12=432 A-B System.out.println(getData(1,2)); // R==\u003e(3+2)^5=243.0 A-C-D System.out.println(getData(4,0)); // R==\u003esqrt(4)= A-C-E } ","date":"2022-03-30","objectID":"/index.zh_cn/:3:1","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"断言 ","date":"2022-03-30","objectID":"/index.zh_cn/:4:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"常用匹配方法 //要求所有的条件都要通过测试才算成功 assertThat(\"hello world\", allOf(startsWith(\"helloo\"), containsString(\"world\"))); //false //如果接下来的所有条件只要有一个成立则测试通过 assertThat(\"hello world\", anyOf(startsWith(\"hello\"), containsString(\"worldd\"))); //true //anything匹配符表明无论什么条件，永远为true assertThat( \"hello world\", is( \"hello\" ) ); //true //is表明如果前面待测的object等于后面给出的object assertThat( \"hello world\", is( \"hello world\") ); //true //not匹配符和is匹配符正好相反，表明如果前面待测的object不等于后面给出的object assertThat( \"hello world\", not( \"hello world\") ); //false //判断是否包含字符串 assertThat( \"helloWorld\", containsString( \"hello\" ) ); //true //判断是否以指定字符串结尾 assertThat( \"helloWorld\", endsWith( \"World\" ) ); //true //判断是否以指定字符串开始 assertThat( \"helloWorld\", startsWith( \"hello\" ) ); //true //equalTo匹配符表明如果测试的testedValue等于expectedValue则测试通过 assertThat( \"hello\", equalTo(\"hello\") ); //判断忽略首尾空格时是否相等 assertThat( \"hello\", equalToIgnoringWhiteSpace( \" hello \" ) ); //true //判断列表中是否包含指定项 assertThat(Arrays.asList(\"foo\", \"bar\"), hasItem(\"bar\")); //判断列表中是否包含多项 assertThat(Arrays.asList(\"foo\", \"bar\", \"baz\"), hasItems(\"baz\", \"foo\")) //判断指定对象是否是某个类（包括子类） assertThat(new ArrayList\u003c\u003e(), instanceOf(List.class)); ","date":"2022-03-30","objectID":"/index.zh_cn/:4:1","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"Junit测试类注解 junit4 junit5 特点 @BeforeClass @BeforeAll 在当前类的所有测试方法之前执行。注解在【静态方法】上。 @AfterClass @AfterAll 在当前类中的所有测试方法之后执行。注解在【静态方法】上。 @Before @BeforeEach 在每个测试方法之前执行。注解在【非静态方法】上。 @After @AfterEach 在每个测试方法之后执行。注解在【非静态方法】上。 ","date":"2022-03-30","objectID":"/index.zh_cn/:5:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"Junit测试套件 public class JunitTestOne { @Test public void test() { System.out.println(\"测试一。。。\"); } } public class JunitTestTwo { @Test public void test() { System.out.println(\"测试二。。。\"); } } ","date":"2022-03-30","objectID":"/index.zh_cn/:6:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"Junit异常测试 例子： @Test(expected = IndexOutOfBoundsException.class) public void test (){ List\u003cString\u003e lists = new ArrayList\u003c\u003e(); lists.get(1); } @expected表达式表示如果方法抛出指定异常则测试通过，以上例子可以通过测试。 ","date":"2022-03-30","objectID":"/index.zh_cn/:7:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"Junit限时测试 例子： @Test(timeout = 1000) public void test (){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } @timeout表达式表示如果方法运行市场超过指定行数则测试不通过，以上案例中使用线程阻塞的方式阻塞线程2000毫秒，超过了规定时间，所以测试不通过。 ","date":"2022-03-30","objectID":"/index.zh_cn/:8:0","tags":["Java"],"title":"Junit使用教程","uri":"/index.zh_cn/"},{"categories":["学习笔记"],"content":"MQTT协议简解 MQTT(消息队列遥测传输)是ISO 标准(ISO/IEC PRF 20922)下基于发布/订阅范式的消息协议。它工作在 TCP/IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议，为此，它需要一个[消息中间件 ](https://baike.baidu.com/item/消息中间件 /5899771)。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 ","date":"2022-03-17","objectID":"/mqtt-study/:1:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"MQTT的实现方式 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分： （1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）； （2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 ","date":"2022-03-17","objectID":"/mqtt-study/:2:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"MQTT的特点 相互可独立：订阅者之间并不知道对方的存在，而发布者也不知道有多少客户端订阅了自己。 空间可分离：只要订阅者、服务器、发布者连接了网络，那么就不受空间距离限制。 时间可异步：订阅者有时并不能立马收到发布者的消息（比如断网），但是当可以接收时可以继续接收到已经发布的消息。 ","date":"2022-03-17","objectID":"/mqtt-study/:3:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"MQTT客户端与服务端连接过程 首先MQTT客户端将会向服务端发送连接请求。该请求实际上是一个包含有连接请求信息的数据包。这个数据包的官方名称为CONNECT。 MQTT服务端收到客户端连接请求后，会向客户端发送连接确认。同样的，该确认也是一个数据包。这个数据包官方名称为CONNACK。 ","date":"2022-03-17","objectID":"/mqtt-study/:4:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"CONNECT报文 在上面的描述中我们看到。MQTT客户端要想连接服务端，首先要向服务端发送CONNECT报文。如果此CONNECT报文的格式或内容不符合MQTT规范，则服务器会拒绝客户端的连接请求。 下图是CONNECT报文所包含的信息内容。 clientId – 客户端ID ClientId是MQTT客户端的标识。MQTT服务端用该标识来识别客户端。因此ClientId必须是独立的。如果两个MQTT客户端使用相同ClientId标识，服务端会把它们当成同一个客户端来处理。通常ClientId是由一串字符所构成的，如上图所示，此示例中的clientID是“client-1”。 cleanSession – 清除会话 cleanSession有两种状态分别为true和false，当设置为true时，服务器将不会确认客户端是否收到消息，也不会保存报文，当设置为false时，服务器发出报文后会等待客户端发送确认报文，如果没有收到确认报文，则会保存报文，等待下次发送。 请注意，如果需要服务端保存重要报文，光设置cleanSession 为false是不够的，还需要传递的MQTT信息QoS级别大于0。 关于QoS的概念，我们会在本教程后续课程中详细讲解。到目前请您务必牢记，如果想让服务器记住重要报文，那么客户端在连接服务端时，需要把cleanSession中设置为false。这一点非常关键，请务必牢记。 **keepAlive – 心跳时间间隔 MQTT服务端运行过程中，当有客户端因为某种原因断开了与服务端的连接，服务端需要实时了解这一情况。KeepAlive （心跳时间间隔）正是用于服务端了解客户端连接情况的目前您只需要记住，KeepAlive用于服务端实时了解客户端是否与其保持连接的情况。 ","date":"2022-03-17","objectID":"/mqtt-study/:4:1","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"CONNACK – 确认连接请求报文 CONNACK报文包括两个信息。一个是returnCode(连接返回码)，另一个是sessionPresent (当前会话)。以下是这两个信息的说明： returnCode – 连接返回码 当服务端收到了客户端的连接请求后，会向客户端发送returnCode(连接返回码)，用以说明连接情况。如果客户端与服务端成功连接，则返回数字“0”。如果未能成功连接，连接返回码将会是一个非零的数值，具体这个数值的含义，请见下表： 返回码 返回码描述 0 成功连接 1 连接被服务端拒绝，原因是不支持客户端的MQTT协议版本 2 连接被服务端拒绝，原因是不支持客户端标识符的编码。 3 连接被服务端拒绝，网络连接已经建立，但MQTT服务不可用。 4 连接被服务端拒绝，原因是用户名或密码无效。 5 连接被服务端拒绝，原因是客户端未被授权连接到此服务端。 sessionPresent – 当前会话 当重要客户端连接服务端时，服务端可能保存着没有得到确认的报文。如果是这样的话，那么客户端在连接服务端时，就会通过sessionPresent来了解服务端是否有之前未能确认的信息。简单来说，sessionpressent携带着是否收到报文的确认信息。 ","date":"2022-03-17","objectID":"/mqtt-study/:4:2","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"什么是Mybatis-plus？ ","date":"2022-03-05","objectID":"/mybatis-plus/:1:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"简介 MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 开源代码：Github [Gitee]https://gitee.com/baomidou/mybatis-plus() 官方文档：https://baomidou.com/pages/24112f/ ","date":"2022-03-05","objectID":"/mybatis-plus/:1:1","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 ","date":"2022-03-05","objectID":"/mybatis-plus/:1:2","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"支持数据库 任何能使用 MyBatis 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。 MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库 ","date":"2022-03-05","objectID":"/mybatis-plus/:1:3","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"第一个使用例子： ","date":"2022-03-05","objectID":"/mybatis-plus/:2:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"数据表结构 ","date":"2022-03-05","objectID":"/mybatis-plus/:2:1","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"配置数据源 spring:datasource:driver-class-name:com.mysql.cj.jdbc.Driverusername:rootpassword:rooturl:jdbc:mysql://localhost:3306/mybatis-plus?useUnicode=true\u0026characterEncoding=utf-8\u0026serverTimezone=GMT%2B8 ","date":"2022-03-05","objectID":"/mybatis-plus/:2:2","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"创建Mapper类 *使用@Repository注解将Mapper注入到spring容器。 @Repository @Mapper public interface UserMapper extends BaseMapper\u003cUser\u003e { } BaseMapper类：mybatis-plus内置类，存放基础sql语句，当我们的查询比较简单时，使用这个类即可快速完成查询。 ","date":"2022-03-05","objectID":"/mybatis-plus/:2:3","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"编写实体类 *此处使用了Lombok注解简化setter/getter方法和构造器 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer id; private String name; private Integer age; private String email; } ","date":"2022-03-05","objectID":"/mybatis-plus/:2:4","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"测试 @SpringBootTest class MybatisPlusApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List\u003cUser\u003e users = userMapper.selectList(null); List\u003cUser\u003e users = userMapper.selectList(null); users.forEach(System.out::println);} } 结果如下 ","date":"2022-03-05","objectID":"/mybatis-plus/:3:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"CRUD ","date":"2022-03-05","objectID":"/mybatis-plus/:4:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"主键生成策略 @TableId注解 public enum IdType { AUTO(0), // 数据库id自增 NONE(1), // 未设置主键 INPUT(2), // 手动输入 ID_WORKER(3), // 默认的全局唯一id UUID(4), // 全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 } ","date":"2022-03-05","objectID":"/mybatis-plus/:4:1","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"自动填充 在实体类中有如下字段 //字段添加填充内容 @TableField(fill = FieldFill.INSERT) private LocalDateTime create_time; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime update_time; @TableField注解：注解填充字段，用于标注需要填充的属性。值为自动填充的触发条件。 编写自定义处理器，实现MetaObjectHandler接口 @Component public class MyHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { this.strictInsertFill(metaObject, \"create_time\", LocalDateTime.class, LocalDateTime.now()); this.strictInsertFill(metaObject, \"update_time\", LocalDateTime.class, LocalDateTime.now()); } @Override public void updateFill(MetaObject metaObject) { this.strictInsertFill(metaObject, \"update_time\", LocalDateTime.class, LocalDateTime.now()); } } 注意标识@Component注解，将自定义处理器注入容器 ","date":"2022-03-05","objectID":"/mybatis-plus/:4:2","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"乐观锁* 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题， 再次更新值测试 悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！ 乐观锁实现方式： 取出记录时，获取当前 version 更新时，带上这个 version 执行更新时， set version = newVersion where version = oldVersion 如果 version 不对，就更新失败 举例： 在表中添加version字段并更新实体类 在实体类的version属性上添加@version注解 @Version private Integer version; 注册组件 ","date":"2022-03-05","objectID":"/mybatis-plus/:4:3","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"查询操作 批量查询 public void testQuery(){ List\u003cUser\u003e users = userMapper.selectBatchIds(Arrays.asList(1,2,3)); users.forEach(System.out::println); } 条件查询 @Test public void testQuery2(){ HashMap\u003cString, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"name\",\"fuck\"); List\u003cUser\u003e users = userMapper.selectByMap(map); users.forEach(System.out::println); } ","date":"2022-03-05","objectID":"/mybatis-plus/:4:4","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"删除操作 和查询无异！！！！！！！！！！！（偷懒） 逻辑删除 物理删除 ：从数据库中直接移除 逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效，类似于回收站！ 测试： 在表中增加字段 deleted 字段 配置application.yml mybatis-plus:global-config:db-config:logic-delete-field:flag# 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)logic-delete-value:1# 逻辑已删除值(默认为 1)logic-not-delete-value:0# 逻辑未删除值(默认为 0) 测试 当我们再次查询时，1号用户将不会被查询到 ","date":"2022-03-05","objectID":"/mybatis-plus/:4:5","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"Wrapper：条件构造器 例子： @Test void contextLoads() { // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper .isNotNull(\"name\") .isNotNull(\"email\") .ge(\"age\",12); userMapper.selectList(wrapper).forEach(System.out::println); } @Test void test2(){ // 查询名字狂神说 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.eq(\"name\",\"狂神说\"); User user = userMapper.selectOne(wrapper); 或者 Map System.out.println(user); } @Test void test3(){ // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.between(\"age\",20,30); // 区间 Integer count = userMapper.selectCount(wrapper);// 查询结果数 System.out.println(count); } // 模糊查询 @Test void test5(){ QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); // id 在子查询中查出来 wrapper.inSql(\"id\",\"select id from user where id\u003c3\"); List\u003cObject\u003e objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println); } //测试六 @Test void test6(){ QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); // 通过id进行排序 wrapper.orderByAsc(\"id\"); List\u003cUser\u003e users = userMapper.selectList(wrapper); users.forEach(System.out::println); } ","date":"2022-03-05","objectID":"/mybatis-plus/:5:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["折腾记录"],"content":"腾讯企业邮箱 协议 服务器地址 端口号 IMAP(接收) imap.exmail.qq.com 993 SMTP(发送) smtp.exmail.qq.com 465 POP3 pop.exmail.qq.com 995 ","date":"2022-03-05","objectID":"/mail-config/:1:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["折腾记录"],"content":"网易云邮箱 网易163免费邮箱相关服务器信息： 协议 服务器地址 端口号 IMAP(接收) imap.163.com 993 SMTP(发送) smtp.163.com 465/994 POP3 pop.163.com 995 ","date":"2022-03-05","objectID":"/mail-config/:2:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["折腾记录"],"content":"QQ邮箱 QQ邮箱相关服务器信息： 协议 服务器地址 端口号 IMAP(接收) imap.qq.com 993 SMTP(发送) smtp.qq.com 465/587 POP3 pop.163.com 995 **账户名：**您的QQ邮箱账户名 **密码：**您的QQ邮箱密码 ","date":"2022-03-05","objectID":"/mail-config/:3:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["折腾记录"],"content":"Gmail Google邮箱相关服务器信息： 协议 服务器地址 端口号 IMAP(接收) imap.gmail.com 993 SMTP(发送) smtp.gmail.com 465 POP3 pop.163.com 995 完整名称：您的姓名 帐号名、用户名或：您的完整电子邮件地址 密码：您的 Gmail 密码 ","date":"2022-03-05","objectID":"/mail-config/:4:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["学习笔记"],"content":"什么是SpringBoot？ Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 简单来说，springboot就是会我们自动配置spring框架，从而简化开发流程。 所以约定大于配置变得尤为重要。 ","date":"2022-03-01","objectID":"/springboot-study/:1:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"构建SpringBoot程序 ","date":"2022-03-01","objectID":"/springboot-study/:2:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"方式一、从官网构建 在以下网站中初始化配置后，下载到本地使用idea导入即可。 https://start.spring.io/ ","date":"2022-03-01","objectID":"/springboot-study/:2:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"方式二、使用idea自带方式构建 在new project窗口中选择Spring initializr，然后初始化配置即可。 tips:在resources目录下修改或新建banner.txt可以修改spring启动时欢迎语 模板: _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ .' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '\u003c `.___\\_\u003c|\u003e_/___.' \u003e'\"\". | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / ======`-.____`-.___\\_____/___.-`____.-'====== `=---=' ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG 效果： ","date":"2022-03-01","objectID":"/springboot-study/:2:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"SpringBoot原理初探 ","date":"2022-03-01","objectID":"/springboot-study/:3:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"1、启动器 spring-boot-starter \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter； ","date":"2022-03-01","objectID":"/springboot-study/:3:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"2、主启动类 默认的主动启动类 //@SpringBootApplication 来标注一个主程序类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class SpringbootApplication { public static void main(String[] args) { //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); } } @SpringBootApplication注解 作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； spring.factories 我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ SpringApplication 这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 ","date":"2022-03-01","objectID":"/springboot-study/:3:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"YAML YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。 YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。 YAML 的配置文件后缀为 .yml，如：application.yml 。 ","date":"2022-03-01","objectID":"/springboot-study/:4:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"基本语法 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#‘表示注释 ","date":"2022-03-01","objectID":"/springboot-study/:4:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"数据类型 YAML 支持以下几种数据类型： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 YAML对象 对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。 也可以使用 key:{key1: value1, key2: value2, …}。 还可以使用缩进表示层级关系； key:child-key:valuechild-key2:value2 YAML数组 - A- B- C YAML 支持多维数组，可以使用行内表示： key:[value1, value2, ...] 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 -- A- B- C 例子 companies:-id:1name:company1price:200W-id:2name:company2price:500W 复合结构 数组和对象可以构成复合结构，例： languages:- Ruby- Perl- Python websites:YAML:yaml.org Ruby:ruby-lang.org Python:python.org Perl:use.perl.org 转换为 json 为： {languages:['Ruby','Perl','Python'],websites:{YAML:'yaml.org',Ruby:'ruby-lang.org',Python:'python.org',Perl:'use.perl.org'}} ","date":"2022-03-01","objectID":"/springboot-study/:4:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"配置文件切换 ","date":"2022-03-01","objectID":"/springboot-study/:5:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"1、多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： #比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了; spring.profiles.active=dev yaml的多文档块 server:port:8081#选择要激活那个环境块spring:profiles:active:prod---server:port:8083spring:profiles:dev#配置环境的名称---server:port:8084spring:profiles:prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ ","date":"2022-03-01","objectID":"/springboot-study/:5:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"2、配置文件加载位置 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 优先级1：项目路径下的config文件夹配置文件 优先级2：项目路径下配置文件 优先级3：资源路径下的config文件夹配置文件 优先级4：资源路径下配置文件 ","date":"2022-03-01","objectID":"/springboot-study/:5:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"使用SpringBoot进行Web开发 ","date":"2022-03-01","objectID":"/springboot-study/:6:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"1、静态资源处理 在springboot中，我们可以使用以下方式处理今天资源。 webjars localhost:8080/webjars/ public，static，/**，resources localhost:8080 优先级 ：resources\u003estatic\u003epublic ","date":"2022-03-01","objectID":"/springboot-study/:6:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"2、模板引擎Thymeleaf 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。 Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本 https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter pom依赖： \u003c!--thymeleaf--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-thymeleaf\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2022-03-01","objectID":"/springboot-study/:6:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"3、页面国际化 国际化的作用就是使页面支持多种语言切换，从而使页面国际化！ 编写配置文件 我们在resources资源文件下新建一个i18n目录，存放国际化配置文件 建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！ 然后就行翻译处理，将所需要翻译的文本翻译后填入对应的文本框中 配置目录：在application.properties中配置 spring.messages.basename=i18n.login 配置页面国际化值 去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…} 配置国际化解析 假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！修改一下前端页面的跳转连接： 我们去写一个处理的组件类！ package com.kuang.component; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; //可以在链接上携带区域信息 public class MyLocaleResolver implements LocaleResolver { //解析请求 @Override public Locale resolveLocale(HttpServletRequest request)hailagn { String language = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的 //如果请求链接不为空 if (!StringUtils.isEmpty(language)){ //分割请求参数 String[] split = language.split(\"_\"); //国家，地区 locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) { } } 为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean； @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } 配置登录拦截器 编写拦截器类 public class LoginHandlerInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object loginUser = request.getSession().getAttribute(\"loginUser\"); if(loginUser==null){ request.setAttribute(\"msg\",\"没有权限，请先登录\"); //转发至主页 request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }else{ return true; } } } 实例化拦截器并注入 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/index.html\",\"/\",\"/user/login\",\"/css/**\",\"/img/**\"); } 拦截请求时注意过滤静态资源，拦截静态资源会导致css样式不可用，无法访问请求等状况。 ","date":"2022-03-01","objectID":"/springboot-study/:6:3","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"SpringBoot整合Mybatis 在绝大多数开发场景中，我们都需要通过数据库进行数据的存储，就目前来说，Mybatis是一个比较常用的持久层框架，他能很好的帮助我们的开发，在下面的例子将会说明如何在springboot中整合mybatis。 官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ Maven仓库地址：https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter ","date":"2022-03-01","objectID":"/springboot-study/:7:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"整合案例： 导Mybatis依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.1.1\u003c/version\u003e \u003c/dependency\u003e 配置数据源： spring:datasource:username:rootpassword:root#?serverTimezone=UTC解决时区的报错url:jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC\u0026useUnicode=true\u0026characterEncoding=utf-8driver-class-name:com.mysql.cj.jdbc.Drivertype:com.alibaba.druid.pool.DruidDataSource#Spring Boot 默认是不注入这些属性值的，需要自己绑定#druid 数据源专有配置initialSize:5minIdle:5maxActive:20maxWait:60000timeBetweenEvictionRunsMillis:60000minEvictableIdleTimeMillis:300000validationQuery:SELECT 1 FROM DUALtestWhileIdle:truetestOnBorrow:falsetestOnReturn:falsepoolPreparedStatements:true#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入#如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4jfilters:stat,wall,log4jmaxPoolPreparedStatementPerConnectionSize:20useGlobalDataSourceStat:trueconnectionProperties:druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 创建测试表： 创建实体类： @Data @AllArgsConstructor @NoArgsConstructor public class User { private int number; private String name; private int age; private String sex; } 5.在application.yml中配置mybatis实体类映射： mybatis:type-aliases-package:com.seawave.pojomapper-locations:classpath:mybatis/mapper/*.xml 6.编写UserMapper \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.seawave.mapper.UserMapper\"\u003e \u003c!-- 查询所有用户--\u003e \u003cselect id=\"queryUserList\" resultType=\"com.seawave.pojo.User\"\u003e select * from student \u003c/select\u003e \u003c!-- 根据id查询用户--\u003e \u003cselect id=\"queryUserById\" resultType=\"User\"\u003e select * from student where id = #{id} \u003c/select\u003e \u003c!--添加一个用户--\u003e \u003cinsert id=\"addUser\" parameterType=\"User\"\u003e insert into student (name, age, sex) values (#{name}, #{age}, #{sex}) \u003c/insert\u003e \u003c!-- 更新一个用户--\u003e \u003cupdate id=\"updateUser\" parameterType=\"User\"\u003e update student set name=#{name}, age=#{age}, sex=#{sex}where id =#{id} \u003c/update\u003e \u003c!--删除一个用户--\u003e \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from student where id = #{id} \u003c/delete\u003e \u003c/mapper\u003e 在测试类中测试是否正常连接数据库 @SpringBootTest class Springboot05MybatisApplicationTests { @Autowired UserMapper userMapper; @Test void contextLoads() { for (User user : userMapper.queryUserList()) { System.out.println(user); } } } 成功即可读取到数据库表内容： vv ","date":"2022-03-01","objectID":"/springboot-study/:7:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"Vue快速入门 以下所有代码均可在浏览器直接运行，替换body即可。为了节省空间，里的内容需自行添加。 ","date":"2022-01-05","objectID":"/vue-study/:0:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"1.导入Vue \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\"\u003e\u003c/script\u003e ","date":"2022-01-05","objectID":"/vue-study/:1:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"2.数据绑定 方式一： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{message}} \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"hello,vue!\" } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 方式二： 通过v-bind指令： \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cspan v-bind:title=\"message\"\u003e悬停几秒查看动态绑定\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" } }) \u003c/script\u003e \u003c/body\u003e 经过以上的操作div中的{{message}}的显示内容已经被绑定到了VUE对象中的message属性上，更改message的值即可动态刷新页面中的值。 ","date":"2022-01-05","objectID":"/vue-study/:2:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"3.条件判断 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1 v-if=\"ok==='a'\"\u003eA\u003c/h1\u003e \u003ch1 v-else-if=\"ok==='b'\"\u003eB\u003c/h1\u003e \u003ch1 v-else\u003eC\u003c/h1\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ ok:'a' } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:3:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"4.语句循环 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cli v-for=\"item in items\"\u003e {{item.message}} \u003c/li\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ items:[ {message:'狂神说java'}, {message:'狂神说vue'}, {message:'狂神说js'} ] } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:4:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"5.双向绑定 \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{message}}\u003cbr\u003e \u003cinput type=\"password\" v-model=\"message\"\u003e\u003c/input\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:5:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"6.计算属性 \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{currentTime1()}}\u003cbr\u003e {{currentTime2}}\u003cbr\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" }, methods:{ currentTime1:function () { return Date.now() } }, computed:{ currentTime2:function () { return Date.now() } } }) \u003c/script\u003e \u003c/body\u003e 调用方式不同。computed直接以对象属性方式调用，不需要加括号，而methods必须要函数执行才可以得到结果。 绑定方式不同。methods与compute纯get方式都是单向绑定，不可以更改输入框中的值。compute的get与set方式是真正的双向绑定。 是否存在缓存。methods没有缓存，调用相同的值计算还是会重新计算。competed有缓存，在值不变的情况下不会再次计算，而是直接使用缓存中的值。 ","date":"2022-01-05","objectID":"/vue-study/:6:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"什么是SpringMVC？ ","date":"2021-12-28","objectID":"/springmvc-study/:1:0","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"1、简介 很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。 SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringMVC也是要简化我们日常Web开发。 ","date":"2021-12-28","objectID":"/springmvc-study/:1:1","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"2、MVC设计模式 MVC设计模式的任务是将包含业务数据的模块与显示模块的视图解耦。这是怎样发生的？在模型和视图之间引入重定向层可以解决问题。此重定向层是控制器，控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。 Model（模型）： View（视图）： Controller（控制器）： ","date":"2021-12-28","objectID":"/springmvc-study/:1:2","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"3、初识SpringMVC 第一步、配置web.xml \u003c!-- 注册DispatcherServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!-- 关联一个springmvc配置文件--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spirngmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 设置启动级别--\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e· \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e 第二步、配置spirngmvc-servlet.xml \u003cbean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/\u003e \u003cbean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/\u003e \u003c!-- 视图解析器:DispatcherServlet给他的ModeLAndVIew--\u003e \u003c!-- 1.获取了ModelAndView的数据--\u003e \u003c!-- 2.解析ModelAndView的试图名字--\u003e \u003c!-- 3.拼接试图名字，找到对应视图--\u003e \u003c!-- 4.将数据渲染到视图上--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前置--\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003c!-- 后缀--\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e\u003c!-- Handler--\u003e \u003cbean id=\"/hello\" class=\"com.seawave.HelloController\"/\u003e \u003c/beans\u003e 第三步、在Controller类中测试 @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { // modelAndView 模型和视图 ModelAndView mv = new ModelAndView(); // 封装对象，放在ModelAndView中 mv.addObject(\"msg\",\"helloSpringMVC\"); // 封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); return mv; } } 结果：在浏览器中显示hellospringmvc。 ","date":"2021-12-28","objectID":"/springmvc-study/:1:3","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"SpringMVC的使用 ","date":"2021-12-28","objectID":"/springmvc-study/:2:0","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"1、使用注解开发SpringMVC 步骤1 ：配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!-- 注册DispatcherServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!-- 关联一个springmvc配置文件--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spirngmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 设置启动级别--\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e tips：此文件除非特殊需求无需变动 步骤2：配置springmvc-servlet \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003ccontext:component-scan base-package=\"com.seawave.controller\"/\u003e \u003cmvc:default-servlet-handler/\u003e \u003cmvc:annotation-driven/\u003e \u003c!-- 视图解析器:DispatcherServlet给他的ModeLAndVIew--\u003e \u003c!-- 1.获取了ModelAndView的数据--\u003e \u003c!-- 2.解析ModelAndView的试图名字--\u003e \u003c!-- 3.拼接试图名字，找到对应视图--\u003e \u003c!-- 4.将数据渲染到视图上--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前置--\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003c!-- 后缀--\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e \u003c/beans\u003e tips:此文件除特殊需求无需变动 步骤3：创建控制器 @Controller @RequestMapping(\"/test\") //非必须 public class HelloController { @RequestMapping(\"/hello\") //真实地址：项目路径/test/hello public String hello(Model model){ model.addAttribute(\"msg\",\"Hello,SpringMVCAnnotation!\"); return \"hello\"; //会被视图解析器处理 } } 此时在浏览器中访问http://localhost:8080/test/hello可以看到后端返回了：Hello,SpringMVCAnnotation! ","date":"2021-12-28","objectID":"/springmvc-study/:2:1","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"2、Restful风格 传统风格与Restful风格对比： 传统：http://baidu.com?search=china Restful：http://baidu.com/china 使用Restful风格可以使同一个url提交不同请求。 示例代码： @Controller public class RestFulController { 方式1：@RequestMapping(value = \"/add/{a}/{b}\",method = RequestMethod.GET) 方式2：@GetMapping(\"/add/{a}/{b}\") public String test1(@PathVariable int a, @PathVariable int b, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 当我们在浏览器中输入http://localhost:8080/add/1/2时，可以得到结果：3 从示例代码中可以看到我们指定了提交方式为GET，我们也可以通过注解的方式直接限定提交方式： @GetMapping @POSTMapping @DELETEMapping ….. ","date":"2021-12-28","objectID":"/springmvc-study/:2:2","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"3、获取请求参数 接收为普通参数 使用springmvc获取前端请求的参数时，只需要在控制器上设置相应的传参即可。 public class Controller { @RequestMapping(\"/add\") public String test1(int a, int b, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 默认情况下，形参类型和请求参数的名称一致，比如当我访问http://localhost:8080/add?a=1\u0026b=2时，那么a变量和b变量便会自动赋值1 和2，当形参名和请求参数名不一致时，我们可以添加@RequestParam 注解使之匹配： public class Controller { @RequestMapping(\"/add\") public String test1(@RequestParam(\"a\") int num1,@RequestParam(\"b\") int num, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 此时请求参数ab的值将会赋值到num1和num2. 接收为实体类 我们可以直接在控制器的形参中添加一个实体类，当前端发送请求时会自动创建该类的实体对象，会自动匹配属性名进行赋值： @RequestMapping(\"/test2\") public String test2( User user){ System.out.println(user); return \"test\"; } 此时我们访问http://localhost:8080/test2?name=zs\u0026id=11\u0026age=21时会创建一个name=zs，id=11，age=21的User对象。 控制台输出如下： User(id=11, name=zs, age=21) 注：请求参数名必须和实体类属性名一致，否则为null ","date":"2021-12-28","objectID":"/springmvc-study/:2:3","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"4、设置编码方式 前后端传递数据时，经常会遇到编码问题，比如中文乱码。springMVC为我们提供了一个现成的过滤器，我们直接在web.xml中配置即可。 \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2021-12-28","objectID":"/springmvc-study/:2:4","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"5、SpringMVC返回数据 大多数情况下，后端所要做的事仅仅是向前端返回数据，这意味着我们并不需要使用到视图解析器返回视图，我们可以给控制器的方法添加@ResponseBody注解来表示此处理器只返回数据。 例子： @Controller public class UserController { @RequestMapping(value = \"/j1\") @ResponseBody //使此控制器不会走视图解析器，直接返回字符串 public String json1(){ String str=\"\"; User user =new User(\"海浪\",20,\"男\"); ObjectMapper mapper=new ObjectMapper(); try { str = mapper.writeValueAsString(user); } catch (JsonProcessingException e) { e.printStackTrace(); } return str; } } 此控制器会返回一个user类的JSON字符串。 我们也可以在控制器类上使用@RestController来表明此控制器下的所有控制器均只返回数据。 ","date":"2021-12-28","objectID":"/springmvc-study/:2:5","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"6、解决SpringMVC返回JSON乱码问题 \u003cbean id=\"utf8Charset\" class=\"java.nio.charset.Charset\" factory-method=\"forName\"\u003e \u003cconstructor-arg value=\"UTF-8\" /\u003e \u003c/bean\u003e \u003cmvc:annotation-driven\u003e \u003cmvc:message-converters register-defaults=\"true\"\u003e \u003cbean class=\"org.springframework.http.converter.StringHttpMessageConverter\"\u003e \u003cconstructor-arg value=\"UTF-8\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"\u003e \u003cproperty name=\"objectMapper\"\u003e \u003cbean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"\u003e \u003cproperty name=\"failOnEmptyBeans\" value=\"false\"/\u003e \u003c/bean\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/mvc:message-converters\u003e \u003c/mvc:annotation-driven\u003e ","date":"2021-12-28","objectID":"/springmvc-study/:2:6","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"什么是Spring？ ","date":"2021-12-17","objectID":"/spring-study/:1:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1、简介 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ","date":"2021-12-17","objectID":"/spring-study/:1:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2、创始人 Rod在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位。更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。有着相当丰富的C/C++技术背景的Rod早在1996年就开始了对Java服务器端技术的研究。他是一个在保险、电子商务和金融行业有着丰富经验的技术顾问，同时也是JSR-154（Servlet 2.4）和JDO 2.0的规范专家、JCP的积极成员。 真正引起了人们的注意的，是在2002年Rod Johnson根据多年经验撰写的《Expert o-ne-on-One J2EE Design and Development》。其中对正统J2EE架构的臃肿、低效的质疑，引发了人们对正统J2EE的反思。这本书也体现了Rod Johnson对技术的态度，技术的选择应该基于实证或是自身的经验，而不是任何形式的偶像崇拜或者门户之见。正是这本书真正地改变了Java世界。基于这本书的代码，Rod Johnson创建了轻量级的容器Spring。Spring的出现，使得正统J2EE架构一统天下的局面被打破。基于Struts+Hibernate+Spring的J2EE架构也逐渐得到人们的认可，甚至在大型的项目架构中也逐渐开始应用。 ","date":"2021-12-17","objectID":"/spring-study/:1:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"3、官网 首页：https://spring.io 下载地址：https://repo1.maven.org/maven2/org/springframework/spring github：https://github.com/spring-projects/spring-framework maven： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e \u003c!--MyBatis整合--\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-17","objectID":"/spring-study/:1:3","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"4.IOC理论 public void setUserDao(UserDao userDao) { this.userDao = userDao; } 使用set来把决定权交给用户，降低系统耦合性。 ","date":"2021-12-17","objectID":"/spring-study/:1:4","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"Spring的使用 ","date":"2021-12-17","objectID":"/spring-study/:2:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.HelloSpring 例子： Dao接口 public interface UserDao { void getUser(); } 实现接口1： public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\"默认获取用户数据\"); } } 实现接口2： public class UserDaoMysqlImpl implements UserDao{ @Override public void getUser() { System.out.println(\"默认获取MYSQL数据\"); } } 业务层： public class UserServiceImpl implements UserService{ private UserDao userDao; @Override public void getUser() { userDao.getUser(); } public void setUserDao(UserDao userDao) { this.userDao = userDao; } } 通过spring实例化： public class MyTest { public static void main(String[] args) { //拿到spring容器 ApplicationContext beans = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) beans.getBean(\"UserServiceImpl\"); userServiceImpl.getUser(); } } 配置文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userImpl\" class=\"com.seawave.dao.UserDaoImpl\"/\u003e \u003cbean id=\"mysqlImpl\" class=\"com.seawave.dao.UserDaoMysqlImpl\"/\u003e \u003cbean id=\"UserServiceImpl\" class=\"com.seawave.service.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"userImpl\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.ioc创建对象的方式 默认使用无参构造 假设我们需要用有参构造创建对象： 方式一：通过下标赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"12\"/\u003e \u003cconstructor-arg index=\"1\" value=\"fuck\"/\u003e \u003c/bean\u003e 方式二：通过属性名赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"id\" value=\"12\"/\u003e \u003cconstructor-arg name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 在配置文件加载的时候，容器中管理的对象就已经初始化了！ ","date":"2021-12-17","objectID":"/spring-study/:2:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"3.Spring配置 3.1、别名 通过别名获取对象 \u003c!-- 别名，可以用过别名获取对象--\u003e \u003calias name=\"user\" alias=\"UserTese\"/\u003e 3.2、bean \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" name=\"userTest\"\u003e \u003c/bean\u003e id:bean对象的唯一标识符，相当于对象名 class：bean对应的全限定名，包名+类型 name：也是别名,可以取多个 3.3、import 用于团队开发，导入其他的bean配置文件，将多个配置文件合并为一个。 \u003cimport resource=\"beans.xml\"/\u003e \u003cimport resource=\"bean1.xml\"/\u003e \u003cimport resource=\"bean2.xml\"/\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:3","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"4.依赖注入 4.1、构造器注入 前面用到的方式即为构造器注入 4.2 Set方式注入【重点】 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器注入 【环境搭建】 1.复杂类型 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 2.真实测试对象 @Data public class Student { private String name; private Address address; private String[]books; private List\u003cString\u003e hobbies; private Map\u003cString,String\u003ecard; private Set\u003cString\u003egames; private Properties info; private String wife; } 复杂类型注入： \u003c!-- 第二种，Bean注入，ref--\u003e \u003cbean id=\"address\" class=\"com.seawave.pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"北京东城\"/\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"com.seawave.pojo.Student\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"address\" ref=\"address\"/\u003e 数组注入： \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e List集合注入: \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e map注入： \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"身份证\" value=\"330629197010232241\"/\u003e \u003centry key=\"银行卡\" value=\"340629197010232231\"/\u003e \u003c/map\u003e \u003c/property\u003e set注入： \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003eLOL\u003c/value\u003e \u003cvalue\u003eCOC\u003c/value\u003e \u003cvalue\u003eBOB\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e null值注入： \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e Properties注入： \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"url\"\u003ehttps://baidu.com\u003c/prop\u003e \u003cprop key=\"username\"\u003eseawave\u003c/prop\u003e \u003cprop key=\"password\"\u003ezgq123\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:4","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"5.bean的作用域 作用域 描述 singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。 request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。 session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 单例模式（默认模式） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"singleton\"\u003e 原型模式（每次从容器中获取都会产生一个新对象） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"prototype\"\u003e 其余的request、session、application、websocket 这些只能在web开发中失效 ","date":"2021-12-17","objectID":"/spring-study/:2:5","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"6.Bean自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性！ 在spring中有三种装配方式： 在xml中显示的配置 在java中显示配置 隐式 的自动装配bean【重要】 测试源代码： 此处的cat和dog是一个复杂类型 \u003cbean id=\"cat\" class=\"com.seawave.pojo.Cat\u003e \u003cproperty name=\"name\" value=\"xiaomiao\"/\u003e \u003c/bean\u003e \u003cbean id=\"dog\" class=\"com.seawave.pojo.Cat\u003e \u003cproperty name=\"name\" value=\"xiaowang\"/\u003e \u003c/bean\u003e 普通写法： \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"cat\" ref=\"cat\"/\u003e \u003cproperty name=\"dog\" ref=\"dog\"/\u003e \u003c/bean\u003e ByName自动装配 会自动在容器上下文中查找和自己对象set方法后面的值对应的beanID，无需手动装配cat和dog类 \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e ByType自动装配 会自动在容器上下文中查找和自己对象属性类型相同的beanID，同理 \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 使用注解进行自动装配 要使用注解须知： 导入约束：context约束 配置注解支持 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e @Autowired：直接在属性名上使用 @nonull：如果标记了这个注解，说明这个属性可以为null。 @required：如果显式定义了此属性，说明这个对象可以为null，否则不允许为空。 ","date":"2021-12-17","objectID":"/spring-study/:2:6","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"7.使用Java的方式配置Spring //这个注解表示这个类被Spring接管。 @Configuration public class MyConfig { //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean public User getUser() { return new User(); } } @Configuration @Data public class User { @Value(\"fuck\") private String name; } ","date":"2021-12-17","objectID":"/spring-study/:2:7","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"代理模式 为什么要学习代理模式？因为这就是SprngAOP的底层！ 代理模式的分类： 静态代理 动态代理 ","date":"2021-12-17","objectID":"/spring-study/:3:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.静态代理 角色分析： 抽象角色：一般会使用接口或者抽象类来解决。 真是角色：被代理的角色。 代理介绍：代理真实角色，代理之后一般会进行附属操作。 客户：访问代理对象的人。 代码步骤： 接口 //租房 public interface Rent { public void rent(); } 真实角色 //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\"房东要出租房子\"); } } 代理角色 package com.seawave.demo01; public class Proxy { private Host host; public Proxy(){ } public Proxy(Host host){ this.host=host; } public void rent(){ seeHouse(); sign(); host.rent(); } public void seeHouse(){ System.out.println(\"中介带你看房\"); } public void sign(){ System.out.println(\"签合同\"); } } 客户访问代理角色 package com.seawave.demo01; public class Client { public static void main(String[] args) { Host host=new Host(); host.rent(); } } 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共业务。 公共业务交给代理角色！实现了业务分工。 公共业务发生扩展的时候，方便管理！ 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍。 ","date":"2021-12-17","objectID":"/spring-study/:3:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.动态代理 动态代理和静态代理角色一样。 动态代理的代理类是动态生成的，不是我们写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理。 package com.seawave.demo03; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用这个类动态生产代理类 public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Object target; //传入被代理的实体类 public void setTarget(Object target) { this.target = target; } public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result =method.invoke(target,args); return result; } public void log(String msg){ System.out.println(\"执行了\"+msg+\"方法\"); } } public class Client { public static void main(String[] args) { ProxyInvocationHandler pih = new ProxyInvocationHandler(); Host host = new Host(); pih.setTarget(host); Rent rent= (Rent) pih.getProxy(); rent.rent(); } } ","date":"2021-12-17","objectID":"/spring-study/:3:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"AOP ","date":"2021-12-17","objectID":"/spring-study/:4:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 ","date":"2021-12-17","objectID":"/spring-study/:4:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.使用Spring实现AOP 使用aop织入需要导入依赖包： \u003cdependency\u003e \u003cgroupId\u003eorg.apache.geronimo.bundles\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.6.8_2\u003c/version\u003e \u003c/dependency\u003e 方式一：使用Spring的API接口 例子： 第一步、配置如下spring配置文件： \u003cbean id=\"userService\" class=\"com.seawave.service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"com.seawave.log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.seawave.log.AfterLog\"/\u003e \u003c!--配置aop--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"poincut\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003c!-- 执行环绕--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"poincut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"poincut\"/\u003e \u003c/aop:config\u003e 第二步、创建如下两个log日志类 public class Log implements MethodBeforeAdvice { @Override //method:要执行的目标对象的方法 //objects：参数 //target//目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } public class AfterLog implements AfterReturningAdvice { @Override //returnValue:返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"返回结果为：\"+returnValue); } } 第三步、在测试类中执行方法 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); } } 运行结果如下 com.seawave.service.UserServiceImpl的add被执行了 增加了一个用户 执行了add返回结果为：null 由此可见，我们通过context.getBean方法从spring容器中得到了一个UserService的代理类，我们可以在执行UserService类的方法之前插入自己的逻辑方法。 方式二：使用自定义类 例子 第一步、新建diy类 public class DiyPointCut { public void before() { System.out.println(\"===========方法执行前==========\"); } public void after() { System.out.println(\"===========方法执行后===========\"); } 第二步、配置spring配置文件 //注册diy类 \u003cbean id=\"diy\" class=\"com.seawave.diy.DiyPointCut\"/\u003e \u003c!--方式二--\u003e \u003caop:config\u003e \u003caop:aspect ref=\"diy\"\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e 第三步、在测试类中测试，代码和第一种一样 我们可以得到如下结果： ===========方法执行前========== 增加了一个用户 ===========方法执行后=========== ","date":"2021-12-17","objectID":"/spring-study/:4:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"整合MyBatis 实际开发中，我们通常会使用多哥框架技术，这就需要将mybatis和spring进行整合。 例子 配置数据源和工厂注入 \u003c!-- 一些基本配置 --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/bean\u003e \u003c!--创建sqlsession工厂--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--此配置项用于连接原有的mabatis配置文件，因此mybatis配置文件仍可使用。--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:com/seawave/mapper/UserMapper.xml\"/\u003e \u003c/bean\u003e \u003cbean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"\u003e \u003c!-- 只能使用构造器注入sqlSessionFactory--\u003e \u003cconstructor-arg index=\"0\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e 我们可以看到： 我们将原有的mybatis配置文件通过注入的方式放到了spring的配置文件中。 上述配置项都是一些固定的配置。 创建接口实现类 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u003cUser\u003e getUsers() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUsers(); } 注意 setSqlSession方法必不可少，缺少会导致spring无法注入。 注入实现类 \u003cbean id=\"userMapper\" class=\"com.seawave.mapper.UserMapperImpl\"\u003e \u003cproperty name=\"sqlSession\" ref=\"sqlSession\"/\u003e \u003c/bean\u003e 测试 public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-dao.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } ","date":"2021-12-17","objectID":"/spring-study/:5:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"Spring事务 事务是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为原子性、一致性、隔离性和持久性 (ACID) 属性，只有这样才能成为一个事务。事务一般都是与数据库打交道的操作。 简单来说，事务就是将一系列要做的事情放在一起，要么一起成功，要么一起失败。 spring提供了以下两种事务： 声明式事务 编程式事务 本文将举例声明式事务。 例子： 在UserMapper中配置如下sql语句： \u003cmapper namespace=\"com.seawave.mapper.UserMapper\"\u003e \u003cselect id=\"getUsers\" resultType=\"user\"\u003e select * from user \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"user\"\u003e insert into user (id,name) values (#{id} , #{name}); \u003c/insert\u003e \u003cdelete id=\"delete\" parameterType=\"user\"\u003e deletes from user where id=#{id}; \u003c/delete\u003e \u003c/mapper\u003e 可以看到，我们故意将delete写错成deletes，以此来模仿业务逻辑中的错误。 配置spring配置文件： \u003c!-- 配置声明式事务--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003c!-- 结合APO实现事务的织入--\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"\u003e \u003c!-- 给哪些方法配置事务--\u003e \u003ctx:attributes\u003e \u003ctx:method name=\"getUsers\"/\u003e \u003ctx:method name=\"insertUser\"/\u003e \u003ctx:method name=\"deleteUser\"/\u003e \u003c!-- 配置事务的传播特性--\u003e \u003ctx:method name=\"select\" read-only=\"true\"/\u003e \u003c/tx:attributes\u003e \u003c/tx:advice\u003e \u003c!-- 配置事务切入--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"txPointCut\" expression=\"execution(* com.seawave.mapper.*.* (..))\"/\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/\u003e \u003c/aop:config\u003e 测试： public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } 此时运行程序会提示sql语句错误，但是并没有执行insertUser中的插入语句，如果我们注释掉第二步中的语句，那么将会产生插入成功，删除失败的现象。而此时对于插入和删除这两个操作来说，他们是一致的，其中一个失败另外一个也不会执行。 ","date":"2021-12-17","objectID":"/spring-study/:6:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"·什么是MyBatis？ ","date":"2021-12-05","objectID":"/mybatis-study/:1:0","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"1.MyBatis介绍 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免 了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注 解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对 象)映射成数据库中的记录。 ","date":"2021-12-05","objectID":"/mybatis-study/:1:1","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"2.如何获取MyBatis有关的信息？ MyBatis官方文档：https://mybatis.org/mybatis-3 MyBatis项目地址：https://github.com/mybatis/mybatis-3 Maven中央仓库：https://mvnrepository.com ","date":"2021-12-05","objectID":"/mybatis-study/:1:2","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"MyBatis的安装 ","date":"2021-12-05","objectID":"/mybatis-study/:2:0","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"方式一：在idea中配置MyBatis 首先创建一个maven项目，然后在pom.xml中添加依赖列表： \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:2:1","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"方式二：手动导入jar包 点击此处在github上下载jar包，解压后放入导入idea项目即可 ","date":"2021-12-05","objectID":"/mybatis-study/:2:2","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"MyBatis的使用（idea+maven） ","date":"2021-12-05","objectID":"/mybatis-study/:3:0","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"1.在你的资源目录创建mybatis-config.xml配置文件（构建 SqlSessionFactory） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"org/mybatis/example/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 其中需要注意的是： driver项的值需要改为具体的数据库驱动全类名。 url，username，password需要根据实际情况进行更改。 mapper中resource指向sql语句列表，这一项后面会提及。 ","date":"2021-12-05","objectID":"/mybatis-study/:3:1","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"2.从 SqlSessionFactory 中获取 SqlSession //创建工厂 String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //从工厂中获取sqlSession try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); } ","date":"2021-12-05","objectID":"/mybatis-study/:3:2","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"3.SQL语句映射 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"org.mybatis.example.BlogMapper\"\u003e \u003cselect id=\"selectBlog\" resultType=\"Blog\"\u003e select * from Blog where id = #{id} \u003c/select\u003e \u003c/mapper\u003e 在上述代码中我们需要更改以下几项： namespace:他指向你所需要映射的java接口 id:映射方法的名称 resultType指明返回类型 不可或缺的是，我们需要更改查询语句。 ","date":"2021-12-05","objectID":"/mybatis-study/:3:3","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"4.ResultMap结果集映射 当数据库字段名和属性名不一致时，会导致实体类中的属性值为null，例子如下： //实体类的属性如下： class user{ int name; int password; } //接口方法 void getUser(); \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" type=com.example.User\u003e select * name,pwd from users \u003c/select\u003e 此时返回的User类中的password属性值为null，对于这个问题我们可以在mapper配置文件中添加resultMap标签来解决。 \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" resultmap=com.example.User\u003e select * name,pwd from users \u003c/select\u003e \u003c!--新增resultMap标签--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column表示数据库中的字段，property表示实体类中的属性 --\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:4","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"5.多对一的处理 在实际查询数据库的过程中，大概率会遇到多对一的情况，比如多个学生对应一个老师，我们查询寻学生时需要连同老师一起查询，这时我们需要对结果集做一些修改。 例子： //实体类的属性如下： class Student{ int id; String name; Teacher teacher } //接口方法 void getStudent(); 很明显 以上User类中的Teacher属性是一个复杂类型，所以我们需要单独处理。 方法一 类似于子查询的方法 \u003cselect id = \"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student \u003c/select\u003e \u003cresultMap id =\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" colum=\"id\"/\u003e \u003cresult property=\"name\"colum=\"name\"/\u003e \u003c!-- 复杂的属性，单独处理。对象：association 集合：collection --\u003e \u003cassociation property=\"teacher\" colum=\"tid\" javaType=\"Teacher\" select=\"getTcher\"/\u003e \u003c!--单独查询Teacher的语句--\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id=#{id} \u003c/select\u003e \u003c/result\u003e 方法二 按照结果嵌套处理 \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type =\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:5","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"6. 一对多的处理 与多对一相反,我们会遇到一对多的情况,比如说一个老师对应多个老师,所以我们同样需要对结果集进行处理. 例子: //实体类 public class Teacher{ private int id; private String name; private List\u003cStudent\u003e students; } //接口方法 class TeacherMapper{ Teacher getTeacher(int id); } \u003cselect id=\"getTeacher\" resultMapper=\"\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id and t.id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type =\"Teacher\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003ccollection property=\"teacher\" TypeOf=\"Stident\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:6","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["各种笔记"],"content":"Markdown简介 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 来自：百度百科 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:1:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"一、Markdown标题 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.使用 = 和 - 标记 我展示的是一级标题 ================= 我展示的是二级标题 显示效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.使用#号标记 用#号标记标题时要注意#号与标题文本中间的空格 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ####### 六级标题 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"二、Markdown段落 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.段落分段 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.字体格式 Markdown可以使用如下字体格式： 斜体文本 —文字首末分别使用一*包围文本 斜体文本 —文字首末分别使用一个_包围文本 粗体文本 —文字首末分别使用两个*包围文本 粗体文本 —文字首末分别使用两个_包围文本 删除文本 —文字首末分别使用两个~包围文本 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"3.分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ----- 显示效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:3","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"4. 下划线 下划线可以通过 HTML 的 标签来实现： \u003cu\u003e带下划线的文本\u003c/u\u003e 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:4","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"5.脚注 创建脚注格式类似这样 [^1]。 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:5","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"三、Markdown列表 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.无序列表 无序列表使用星号()、加号(+)或是减号(-*)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.有序列表 有序列表使用数字标记，后面同样需要加一个空格在填写内容： 1. 第一项 2. 第二项 3. 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"3.列表嵌套 列表是可以嵌套的，达到分级效果。 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:3","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"四、Markdown区块 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.普通区块 Markdown 区块引用是在段落开头使用 \u003e 符号 ，然后后面紧跟一个空格符号： \u003e Markdown \u003e 我们都有一个家 \u003e 名字叫中国 效果如下: ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.区块嵌套 区块是可以嵌套的，一个 \u003e 符号是最外层，两个 \u003e 符号是第一层嵌套，以此类推： \u003e 最外层 \u003e \u003e 第一层嵌套 \u003e \u003e \u003e 第二层嵌套 区块也可以和列表互相嵌套： * 第一项 \u003e 区块列表 \u003e 区块列表的嵌套 * 第二项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"五、Markdown 代码 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.代码片段 如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如： `System.out.println(Markdown)` 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.代码区块 代码区块用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： ```javascript $(document).ready(function () { alert('RUNOOB'); }); ​``` 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"六、Markdown 链接 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.超链接 链接使用方法如下： 欢迎来到我的博客 [点击进入](https://seawave.top) 效果如下： 欢迎来到我的博客 点击进入 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.高级链接 我们可以通过变量来设置一个链接，变量赋值在文档末尾进行： 此方法可以使用在需要大量引用同一网址的文档中。 点击进入 [Google][1] 点击进入 [seawave][2] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [2]: http://www.seawave.com/ 效果如下： 点击进入 Google 点击进入 seawave 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"七、Markdown 图片 Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \"可选标题\") 使用举例： ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png) ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png \"100years\") 效果如下: 100yearsBaidu 图标 \"\r100years\r 当然，你也可以像网址那样对图片网址使用变量: 这个链接用 1 作为网址变量 [Gitee][1]. 然后在文档的结尾为变量赋值（网址） [1]: https://gitee.com/static/images/logo-black.svg 效果如下： 这个链接用 1 作为网址变量 Gitee. 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown-basics-guide/:8:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"八、Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 实例如下： | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:9:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["Windows小技巧"],"content":"SakuraFrp简介 SakuraFrp是目前市面上少有的免费内网穿透平台，可以用于个人搭建服务器和做一些应用的流量穿透。花生壳虽然也有免费的，但是带宽和流量都有很大限制，SakuraFrp免费用户就可提供10Mbps和6GB的流量相比之下这个平台算是比较良心的了。 点此处进入Sakura官网 ","date":"2021-01-12","objectID":"/remote-desktop/:1:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接端和被链接端准备 这里我们以win10 20H2版本做演示 1.按WIN+R打开运行窗口 2.在运行窗口输入 SystemPropertiesRemote 3.在远程协助中勾选 允许远程协助链接这台计算机 在远程桌面中选择 允许远程连接到此计算机 4.确定。到此配置完毕。 ","date":"2021-01-12","objectID":"/remote-desktop/:2:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"创建SakuraFrp隧道 1.注册账号 2.创建隧道： 节点最好是选国内的，联通还是电信根据你自己的网络环境来选。 隧道名称随意，取一个你自己能分辨的就行 隧道类型 选TCP 本地地址填127.0.0.1 本地端口填3389（windows远程连接的端口号） 远程端口留空即可 4.单击确认创建，完成创建。 ","date":"2021-01-12","objectID":"/remote-desktop/:3:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接隧道 1.下载Sakura客户端。单击下载 无法下载可以在主页点击软件下载手动选择windows客户端。 2.打开客户端并登录 （可以选择开机自启这样每次开机会自动连接到隧道） 3.点击隧道，可以看到我们刚刚创建的隧道。 4.点击启动开关启动隧道，这样你的电脑就成功连接到了sakura服务器。电脑右下角会给出一个通知，提示连接方式。 来不及保存的话可以点击软件左侧的日志选项，里面会写出你连接到你电脑所需的IP和端口号。 5.保存所提示的IP或域名，选择其中一种即可。 ","date":"2021-01-12","objectID":"/remote-desktop/:4:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"在其他电脑上连接到你的电脑 1.打开远程连接工具。 第1种方法：win+r打开运行窗口，输入mstsc。 第2种方法：单击开始菜单，在附件中找到远程桌面连接。 2.输入你的ip:端口。 3.完成你的连接。 ","date":"2021-01-12","objectID":"/remote-desktop/:5:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":null,"content":"关于我 目前还只是个在学习的小白罢了，不值一提。 ","date":"2020-12-04","objectID":"/about/:0:1","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于我的博客 记录一些笔记 都是一些基础的东西，大佬勿看 偶尔会更新一些计算机方面的技巧 ","date":"2020-12-04","objectID":"/about/:0:2","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于我的理想 现阶段学好后端 长远向全栈努力吧 emmmmm成为一个大佬 ","date":"2020-12-04","objectID":"/about/:0:3","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于此站点 此站点由Hugo强力驱动 主题：LoveIt ","date":"2020-12-04","objectID":"/about/:0:4","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"欢迎来到Seawave的博客 ","date":"2020-12-03","objectID":"/my-first-post/:0:1","tags":null,"title":"My First Blog","uri":"/my-first-post/"}]