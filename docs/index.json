[{"categories":["学习笔记"],"content":"什么是Spring？ ","date":"2021-12-17","objectID":"/spring/:1:0","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"1、简介 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ","date":"2021-12-17","objectID":"/spring/:1:1","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"2、创始人 Rod在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位。更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。有着相当丰富的C/C++技术背景的Rod早在1996年就开始了对Java服务器端技术的研究。他是一个在保险、电子商务和金融行业有着丰富经验的技术顾问，同时也是JSR-154（Servlet 2.4）和JDO 2.0的规范专家、JCP的积极成员。 真正引起了人们的注意的，是在2002年Rod Johnson根据多年经验撰写的《Expert o-ne-on-One J2EE Design and Development》。其中对正统J2EE架构的臃肿、低效的质疑，引发了人们对正统J2EE的反思。这本书也体现了Rod Johnson对技术的态度，技术的选择应该基于实证或是自身的经验，而不是任何形式的偶像崇拜或者门户之见。正是这本书真正地改变了Java世界。基于这本书的代码，Rod Johnson创建了轻量级的容器Spring。Spring的出现，使得正统J2EE架构一统天下的局面被打破。基于Struts+Hibernate+Spring的J2EE架构也逐渐得到人们的认可，甚至在大型的项目架构中也逐渐开始应用。 ","date":"2021-12-17","objectID":"/spring/:1:2","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"3、官网 首页：https://spring.io 下载地址：https://repo1.maven.org/maven2/org/springframework/spring github：https://github.com/spring-projects/spring-framework maven： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e \u003c!--MyBatis整合--\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-17","objectID":"/spring/:1:3","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"4.IOC理论 public void setUserDao(UserDao userDao) { this.userDao = userDao; } 使用set来把决定权交给用户，降低系统耦合性。 ","date":"2021-12-17","objectID":"/spring/:1:4","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"Spring的使用 ","date":"2021-12-17","objectID":"/spring/:2:0","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"1.HelloSpring 例子： Dao接口 public interface UserDao { void getUser(); } 实现接口1： public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\"默认获取用户数据\"); } } 实现接口2： public class UserDaoMysqlImpl implements UserDao{ @Override public void getUser() { System.out.println(\"默认获取MYSQL数据\"); } } 业务层： public class UserServiceImpl implements UserService{ private UserDao userDao; @Override public void getUser() { userDao.getUser(); } public void setUserDao(UserDao userDao) { this.userDao = userDao; } } 通过spring实例化： public class MyTest { public static void main(String[] args) { //拿到spring容器 ApplicationContext beans = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) beans.getBean(\"UserServiceImpl\"); userServiceImpl.getUser(); } } 配置文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userImpl\" class=\"com.seawave.dao.UserDaoImpl\"/\u003e \u003cbean id=\"mysqlImpl\" class=\"com.seawave.dao.UserDaoMysqlImpl\"/\u003e \u003cbean id=\"UserServiceImpl\" class=\"com.seawave.service.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"userImpl\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"2021-12-17","objectID":"/spring/:2:1","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"2.ioc创建对象的方式 默认使用无参构造 假设我们需要用有参构造创建对象： 方式一：通过下标赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"12\"/\u003e \u003cconstructor-arg index=\"1\" value=\"fuck\"/\u003e \u003c/bean\u003e 方式二：通过属性名赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"id\" value=\"12\"/\u003e \u003cconstructor-arg name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 在配置文件加载的时候，容器中管理的对象就已经初始化了！ ","date":"2021-12-17","objectID":"/spring/:2:2","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"3.Spring配置 3.1、别名 通过别名获取对象 \u003c!-- 别名，可以用过别名获取对象--\u003e \u003calias name=\"user\" alias=\"UserTese\"/\u003e 3.2、bean \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" name=\"userTest\"\u003e \u003cconstructor-arg index=\"0\" value=\"12\"/\u003e \u003cconstructor-arg index=\"1\" value=\"fuck\"/\u003e \u003c/bean\u003e id:bean对象的唯一标识符，相当于对象名 class：bean对应的全限定名，包名+类型 name：也是别名,可以取多个 3.3、import 用于团队开发，导入其他的bean配置文件，将多个配置文件合并为一个。 \u003cimport resource=\"beans.xml\"/\u003e \u003cimport resource=\"bean1.xml\"/\u003e \u003cimport resource=\"bean2.xml\"/\u003e ","date":"2021-12-17","objectID":"/spring/:2:3","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"4.依赖注入 4.1、构造器注入 前面用到的方式即为构造器注入 4.2 Set方式注入【重点】 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器注入 【环境搭建】 1.复杂类型 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 2.真实测试对象 @Data public class Student { private String name; private Address address; private String[]books; private List\u003cString\u003e hobbies; private Map\u003cString,String\u003ecard; private Set\u003cString\u003egames; private Properties info; private String wife; } 复杂类型注入： \u003c!-- 第二种，Bean注入，ref--\u003e \u003cbean id=\"address\" class=\"com.seawave.pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"北京东城\"/\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"com.seawave.pojo.Student\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"address\" ref=\"address\"/\u003e 数组注入： \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e List集合注入: \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e map注入： \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"身份证\" value=\"330629197010232241\"/\u003e \u003centry key=\"银行卡\" value=\"340629197010232231\"/\u003e \u003c/map\u003e \u003c/property\u003e set注入： \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003eLOL\u003c/value\u003e \u003cvalue\u003eCOC\u003c/value\u003e \u003cvalue\u003eBOB\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e null值注入： \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e Properties注入： \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"url\"\u003ehttps://baidu.com\u003c/prop\u003e \u003cprop key=\"username\"\u003eseawave\u003c/prop\u003e \u003cprop key=\"password\"\u003ezgq123\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e ","date":"2021-12-17","objectID":"/spring/:2:4","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"5.bean的作用域 作用域 描述 singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。 request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。 session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 单例模式（默认模式） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"singleton\"\u003e 原型模式（每次从容器中获取都会产生一个新对象） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"prototype\"\u003e 其余的request、session、application、websocket 这些只能在web开发中失效 ","date":"2021-12-17","objectID":"/spring/:2:5","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"6.Bean自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性！ 在spring中有三种装配方式： 在xml中显示的配置 在java中显示配置 隐式 的自动装配bean【重要】 测试源代码： \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"cat\" ref=\"cat\"/\u003e \u003cproperty name=\"dog\" ref=\"dog\"/\u003e \u003c/bean\u003e ByName自动装配 会自动在容器上下文中查找和自己对象set方法后面的值对应的beanID \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e ByType自动装配 会自动在容器上下文中查找和自己对象属性类型相同的beanID \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 使用注解进行自动装配 要使用注解须知： 导入约束：context约束 配置注解支持 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e @Autowired：直接在属性名上使用 @nonull：如果标记了这个注解，说明这个属性可以为null。 @required：如果显式定义了此属性，说明这个对象可以为null，否则不允许为空。 ","date":"2021-12-17","objectID":"/spring/:2:6","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"7.使用Java的方式配置Spring //这个注解表示这个类被Spring接管。 @Configuration public class MyConfig { //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean public User getUser() { return new User(); } } @Configuration @Data public class User { @Value(\"fuck\") private String name; } ","date":"2021-12-17","objectID":"/spring/:2:7","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"代理模式 为什么要学习代理模式？因为这就是SprngAOP的底层！ 代理模式的分类： 静态代理 动态代理 ","date":"2021-12-17","objectID":"/spring/:3:0","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"1.静态代理 角色分析： 抽象角色：一般会使用接口或者抽象类来解决。 真是角色：被代理的角色。 代理介绍：代理真实角色，代理之后一般会进行附属操作。 客户：访问代理对象的人。 代码步骤： 接口 //租房 public interface Rent { public void rent(); } 真实角色 //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\"房东要出租房子\"); } } 代理角色 package com.seawave.demo01; public class Proxy { private Host host; public Proxy(){ } public Proxy(Host host){ this.host=host; } public void rent(){ seeHouse(); sign(); host.rent(); } public void seeHouse(){ System.out.println(\"中介带你看房\"); } public void sign(){ System.out.println(\"签合同\"); } } 客户访问代理角色 package com.seawave.demo01; public class Client { public static void main(String[] args) { Host host=new Host(); host.rent(); } } 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共业务。 公共业务交给代理角色！实现了业务分工。 公共业务发生扩展的时候，方便管理！ 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍。 ","date":"2021-12-17","objectID":"/spring/:3:1","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"2.动态代理 动态代理和静态代理角色一样。 动态代理的代理类是动态生成的，不是我们写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理。 package com.seawave.demo03; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用这个类动态生产代理类 public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Object target; //传入被代理的实体类 public void setTarget(Object target) { this.target = target; } public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result =method.invoke(target,args); return result; } public void log(String msg){ System.out.println(\"执行了\"+msg+\"方法\"); } } public class Client { public static void main(String[] args) { ProxyInvocationHandler pih = new ProxyInvocationHandler(); Host host = new Host(); pih.setTarget(host); Rent rent= (Rent) pih.getProxy(); rent.rent(); } } ","date":"2021-12-17","objectID":"/spring/:3:2","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"AOP ","date":"2021-12-17","objectID":"/spring/:4:0","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"1.什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 ","date":"2021-12-17","objectID":"/spring/:4:1","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"2.使用Spring实现AOP 使用aop织入需要导入依赖包： \u003cdependency\u003e \u003cgroupId\u003eorg.apache.geronimo.bundles\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.6.8_2\u003c/version\u003e \u003c/dependency\u003e 方式一：使用Spring的API接口 例子： 第一步、配置如下spring配置文件： \u003cbean id=\"userService\" class=\"com.seawave.service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"com.seawave.log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.seawave.log.AfterLog\"/\u003e \u003c!--配置aop--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"poincut\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003c!-- 执行环绕--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"poincut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"poincut\"/\u003e \u003c/aop:config\u003e 第二步、创建如下两个log日志类 public class Log implements MethodBeforeAdvice { @Override //method:要执行的目标对象的方法 //objects：参数 //target//目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } public class AfterLog implements AfterReturningAdvice { @Override //returnValue:返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"返回结果为：\"+returnValue); } } 第三步、在测试类中执行方法 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); } } 运行结果如下 com.seawave.service.UserServiceImpl的add被执行了 增加了一个用户 执行了add返回结果为：null 由此可见，我们通过context.getBean方法从spring容器中得到了一个UserService的代理类，我们可以在执行UserService类的方法之前插入自己的逻辑方法。 方式二：使用自定义类 例子 第一步、新建diy类 public class DiyPointCut { public void before() { System.out.println(\"===========方法执行前==========\"); } public void after() { System.out.println(\"===========方法执行后===========\"); } 第二步、配置spring配置文件 //注册diy类 \u003cbean id=\"diy\" class=\"com.seawave.diy.DiyPointCut\"/\u003e \u003c!--方式二--\u003e \u003caop:config\u003e \u003caop:aspect ref=\"diy\"\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e 第三步、在测试类中测试，代码和第一种一样 我们可以得到如下结果： ===========方法执行前========== 增加了一个用户 ===========方法执行后=========== ","date":"2021-12-17","objectID":"/spring/:4:2","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"整合MyBatis 实际开发中，我们通常会使用多哥框架技术，这就需要将mybatis和spring进行整合。 例子 配置数据源和工厂注入 \u003c!-- 一些基本配置 --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/bean\u003e \u003c!--创建sqlsession工厂--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--此配置项用于连接原有的mabatis配置文件，因此mybatis配置文件仍可使用。--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:com/seawave/mapper/UserMapper.xml\"/\u003e \u003c/bean\u003e \u003cbean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"\u003e \u003c!-- 只能使用构造器注入sqlSessionFactory--\u003e \u003cconstructor-arg index=\"0\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e 我们可以看到： 我们将原有的mybatis配置文件通过注入的方式放到了spring的配置文件中。 上述配置项都是一些固定的配置。 创建接口实现类 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u003cUser\u003e getUsers() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUsers(); } 注意 setSqlSession方法必不可少，缺少会导致spring无法注入。 注入实现类 \u003cbean id=\"userMapper\" class=\"com.seawave.mapper.UserMapperImpl\"\u003e \u003cproperty name=\"sqlSession\" ref=\"sqlSession\"/\u003e \u003c/bean\u003e 测试 public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-dao.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } ","date":"2021-12-17","objectID":"/spring/:5:0","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"Spring事务 事务是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为原子性、一致性、隔离性和持久性 (ACID) 属性，只有这样才能成为一个事务。事务一般都是与数据库打交道的操作。 简单来说，事务就是将一系列要做的事情放在一起，要么一起成功，要么一起失败。 spring提供了以下两种事务： 声明式事务 编程式事务 本文将举例声明式事务。 例子： 在UserMapper中配置如下sql语句： \u003cmapper namespace=\"com.seawave.mapper.UserMapper\"\u003e \u003cselect id=\"getUsers\" resultType=\"user\"\u003e select * from user \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"user\"\u003e insert into user (id,name) values (#{id} , #{name}); \u003c/insert\u003e \u003cdelete id=\"delete\" parameterType=\"user\"\u003e deletes from user where id=#{id}; \u003c/delete\u003e \u003c/mapper\u003e 可以看到，我们故意将delete写错成deletes，以此来模仿业务逻辑中的错误。 配置spring配置文件： \u003c!-- 配置声明式事务--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003c!-- 结合APO实现事务的织入--\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"\u003e \u003c!-- 给哪些方法配置事务--\u003e \u003ctx:attributes\u003e \u003ctx:method name=\"getUsers\"/\u003e \u003ctx:method name=\"insertUser\"/\u003e \u003ctx:method name=\"deleteUser\"/\u003e \u003c!-- 配置事务的传播特性--\u003e \u003ctx:method name=\"select\" read-only=\"true\"/\u003e \u003c/tx:attributes\u003e \u003c/tx:advice\u003e \u003c!-- 配置事务切入--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"txPointCut\" expression=\"execution(* com.seawave.mapper.*.* (..))\"/\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/\u003e \u003c/aop:config\u003e 测试： public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } 此时运行程序会提示sql语句错误，但是并没有执行insertUser中的插入语句，如果我们注释掉第二步中的语句，那么将会产生插入成功，删除失败的现象。而此时对于插入和删除这两个操作来说，他们是一致的，其中一个失败另外一个也不会执行。 ","date":"2021-12-17","objectID":"/spring/:6:0","tags":null,"title":"初识Spring5","uri":"/spring/"},{"categories":["学习笔记"],"content":"·什么是MyBatis？ ","date":"2021-12-05","objectID":"/mybatis/:1:0","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"1.MyBatis介绍 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免 了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注 解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对 象)映射成数据库中的记录。 ","date":"2021-12-05","objectID":"/mybatis/:1:1","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"2.如何获取MyBatis有关的信息？ MyBatis官方文档：https://mybatis.org/mybatis-3 MyBatis项目地址：https://github.com/mybatis/mybatis-3 Maven中央仓库：https://mvnrepository.com ","date":"2021-12-05","objectID":"/mybatis/:1:2","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"MyBatis的安装 ","date":"2021-12-05","objectID":"/mybatis/:2:0","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"方式一：在idea中配置MyBatis 首先创建一个maven项目，然后在pom.xml中添加依赖列表： \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-05","objectID":"/mybatis/:2:1","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"方式二：手动导入jar包 点击此处在github上下载jar包，解压后放入导入idea项目即可 ","date":"2021-12-05","objectID":"/mybatis/:2:2","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"MyBatis的使用（idea+maven） ","date":"2021-12-05","objectID":"/mybatis/:3:0","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"1.在你的资源目录创建mybatis-config.xml配置文件（构建 SqlSessionFactory） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"org/mybatis/example/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 其中需要注意的是： driver项的值需要改为具体的数据库驱动全类名。 url，username，password需要根据实际情况进行更改。 mapper中resource指向sql语句列表，这一项后面会提及。 ","date":"2021-12-05","objectID":"/mybatis/:3:1","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"2.从 SqlSessionFactory 中获取 SqlSession //创建工厂 String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //从工厂中获取sqlSession try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); } ","date":"2021-12-05","objectID":"/mybatis/:3:2","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"3.SQL语句映射 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"org.mybatis.example.BlogMapper\"\u003e \u003cselect id=\"selectBlog\" resultType=\"Blog\"\u003e select * from Blog where id = #{id} \u003c/select\u003e \u003c/mapper\u003e 在上述代码中我们需要更改以下几项： namespace:他指向你所需要映射的java接口 id:映射方法的名称 resultType指明返回类型 不可或缺的是，我们需要更改查询语句。 ","date":"2021-12-05","objectID":"/mybatis/:3:3","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"4.ResultMap结果集映射 当数据库字段名和属性名不一致时，会导致实体类中的属性值为null，例子如下： //实体类的属性如下： class user{ int name; int password; } //接口方法 void getUser(); \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" type=com.example.User\u003e select * name,pwd from users \u003c/select\u003e 此时返回的User类中的password属性值为null，对于这个问题我们可以在mapper配置文件中添加resultMap标签来解决。 \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" resultmap=com.example.User\u003e select * name,pwd from users \u003c/select\u003e \u003c!--新增resultMap标签--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column表示数据库中的字段，property表示实体类中的属性 --\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis/:3:4","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"5.多对一的处理 在实际查询数据库的过程中，大概率会遇到多对一的情况，比如多个学生对应一个老师，我们查询寻学生时需要连同老师一起查询，这时我们需要对结果集做一些修改。 例子： //实体类的属性如下： class Student{ int id; String name; Teacher teacher } //接口方法 void getStudent(); 很明显 以上User类中的Teacher属性是一个复杂类型，所以我们需要单独处理。 方法一 类似于子查询的方法 \u003cselect id = \"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student \u003c/select\u003e \u003cresultMap id =\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" colum=\"id\"/\u003e \u003cresult property=\"name\"colum=\"name\"/\u003e \u003c!-- 复杂的属性，单独处理。对象：association 集合：collection --\u003e \u003cassociation property=\"teacher\" colum=\"tid\" javaType=\"Teacher\" select=\"getTcher\"/\u003e \u003c!--单独查询Teacher的语句--\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id=#{id} \u003c/select\u003e \u003c/result\u003e 方法二 按照结果嵌套处理 \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type =\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis/:3:5","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["学习笔记"],"content":"6. 一对多的处理 与多对一相反,我们会遇到一对多的情况,比如说一个老师对应多个老师,所以我们同样需要对结果集进行处理. 例子: //实体类 public class Teacher{ private int id; private String name; private List\u003cStudent\u003e students; } //接口方法 class TeacherMapper{ Teacher getTeacher(int id); } \u003cselect id=\"getTeacher\" resultMapper=\"\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id and t.id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type =\"Teacher\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003ccollection property=\"teacher\" TypeOf=\"Stident\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis/:3:6","tags":null,"title":"MyBatis使用教程","uri":"/mybatis/"},{"categories":["各种笔记"],"content":"Markdown简介 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 来自：百度百科 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:1:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"一、Markdown标题 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:2:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"1.使用 = 和 - 标记 我展示的是一级标题 ================= 我展示的是二级标题 显示效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:2:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"2.使用#号标记 用#号标记标题时要注意#号与标题文本中间的空格 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ####### 六级标题 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:2:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"二、Markdown段落 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:3:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"1.段落分段 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:3:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"2.字体格式 Markdown可以使用如下字体格式： 斜体文本 —文字首末分别使用一*包围文本 斜体文本 —文字首末分别使用一个_包围文本 粗体文本 —文字首末分别使用两个*包围文本 粗体文本 —文字首末分别使用两个_包围文本 删除文本 —文字首末分别使用两个~包围文本 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:3:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"3.分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ----- 显示效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:3:3","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"4. 下划线 下划线可以通过 HTML 的 标签来实现： \u003cu\u003e带下划线的文本\u003c/u\u003e 效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:3:4","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"5.脚注 创建脚注格式类似这样 [^1]。 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:3:5","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"三、Markdown列表 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:4:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"1.无序列表 无序列表使用星号()、加号(+)或是减号(-*)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:4:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"2.有序列表 有序列表使用数字标记，后面同样需要加一个空格在填写内容： 1. 第一项 2. 第二项 3. 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:4:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"3.列表嵌套 列表是可以嵌套的，达到分级效果。 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:4:3","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"四、Markdown区块 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:5:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"1.普通区块 Markdown 区块引用是在段落开头使用 \u003e 符号 ，然后后面紧跟一个空格符号： \u003e Markdown \u003e 我们都有一个家 \u003e 名字叫中国 效果如下: ","date":"2021-07-02","objectID":"/markdown_basics_guide/:5:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"2.区块嵌套 区块是可以嵌套的，一个 \u003e 符号是最外层，两个 \u003e 符号是第一层嵌套，以此类推： \u003e 最外层 \u003e \u003e 第一层嵌套 \u003e \u003e \u003e 第二层嵌套 区块也可以和列表互相嵌套： * 第一项 \u003e 区块列表 \u003e 区块列表的嵌套 * 第二项 效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:5:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"五、Markdown 代码 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:6:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"1.代码片段 如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如： `System.out.println(Markdown)` 效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:6:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"2.代码区块 代码区块用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： ​```javascript $(document).ready(function () { alert('RUNOOB'); }); ​``` 效果如下： ","date":"2021-07-02","objectID":"/markdown_basics_guide/:6:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"六、Markdown 链接 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:7:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"1.超链接 链接使用方法如下： 欢迎来到我的博客 [点击进入](https://seawave.top) 效果如下： 欢迎来到我的博客 点击进入 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:7:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"2.高级链接 我们可以通过变量来设置一个链接，变量赋值在文档末尾进行： 此方法可以使用在需要大量引用同一网址的文档中。 点击进入 [Google][1] 点击进入 [seawave][2] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [2]: http://www.seawave.com/ 效果如下： 点击进入 Google 点击进入 seawave 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown_basics_guide/:7:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"七、Markdown 图片 Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \"可选标题\") 使用举例： ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png) ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png \"100years\") 效果如下: 100yearsBaidu 图标 \"\r100years\r 当然，你也可以像网址那样对图片网址使用变量: 这个链接用 1 作为网址变量 [Gitee][1]. 然后在文档的结尾为变量赋值（网址） [1]: https://gitee.com/static/images/logo-black.svg 效果如下： 这个链接用 1 作为网址变量 Gitee. 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown_basics_guide/:8:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["各种笔记"],"content":"八、Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 实例如下： | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 ","date":"2021-07-02","objectID":"/markdown_basics_guide/:9:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown_basics_guide/"},{"categories":["Windows小技巧"],"content":"SakuraFrp简介 SakuraFrp是目前市面上少有的免费内网穿透平台，可以用于个人搭建服务器和做一些应用的流量穿透。花生壳虽然也有免费的，但是带宽和流量都有很大限制，SakuraFrp免费用户就可提供10Mbps和6GB的流量相比之下这个平台算是比较良心的了。 点此处进入Sakura官网 ","date":"2021-01-12","objectID":"/remote-desktop/:1:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接端和被链接端准备 这里我们以win10 20H2版本做演示 1.按WIN+R打开运行窗口 2.在运行窗口输入 SystemPropertiesRemote 3.在远程协助中勾选 允许远程协助链接这台计算机 在远程桌面中选择 允许远程连接到此计算机 4.确定。到此配置完毕。 ","date":"2021-01-12","objectID":"/remote-desktop/:2:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"创建SakuraFrp隧道 1.注册账号 2.创建隧道： 节点最好是选国内的，联通还是电信根据你自己的网络环境来选。 隧道名称随意，取一个你自己能分辨的就行 隧道类型 选TCP 本地地址填127.0.0.1 本地端口填3389（windows远程连接的端口号） 远程端口留空即可 4.单击确认创建，完成创建。 ","date":"2021-01-12","objectID":"/remote-desktop/:3:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接隧道 1.下载Sakura客户端。单击下载 无法下载可以在主页点击软件下载手动选择windows客户端。 2.打开客户端并登录 （可以选择开机自启这样每次开机会自动连接到隧道） 3.点击隧道，可以看到我们刚刚创建的隧道。 4.点击启动开关启动隧道，这样你的电脑就成功连接到了sakura服务器。电脑右下角会给出一个通知，提示连接方式。 来不及保存的话可以点击软件左侧的日志选项，里面会写出你连接到你电脑所需的IP和端口号。 5.保存所提示的IP或域名，选择其中一种即可。 ","date":"2021-01-12","objectID":"/remote-desktop/:4:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"在其他电脑上连接到你的电脑 1.打开远程连接工具。 第1种方法：win+r打开运行窗口，输入mstsc。 第2种方法：单击开始菜单，在附件中找到远程桌面连接。 2.输入你的ip:端口。 3.完成你的连接。 ","date":"2021-01-12","objectID":"/remote-desktop/:5:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":null,"content":"欢迎来到Seawave的博客 ","date":"2020-12-03","objectID":"/my-first-post/:0:1","tags":null,"title":"My First Blog","uri":"/my-first-post/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \"\rHugo Theme LoveIt\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Dynamic scroll supported by Smooth Scroll  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"About LoveIt","uri":"/about/"}]