[{"categories":["学习笔记"],"content":"Git—分布式版本控制系统 ","date":"2022-05-19","objectID":"/git-study/:1:0","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"一、版本控制 ","date":"2022-05-19","objectID":"/git-study/:2:0","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"概述 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程– 减轻开发人员的负担，节省时间，同时降低人为错误 主流的版本控制器有如下这些： Git SVN（Subversion） CVS（Concurrent Versions System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） ","date":"2022-05-19","objectID":"/git-study/:2:1","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"分类 1、本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。 2、集中版本控制 SVN 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改 所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 3、分布式版本控制 所有版本信息仓库全部同步到本地的每个用户，没有中央服务器，每个人的电脑就是一个完整的版本库。这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 Git是目前世界上最先进的分布式版本控制系统。 Git创始人： ","date":"2022-05-19","objectID":"/git-study/:2:2","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"二、Git 安装与配置 ","date":"2022-05-19","objectID":"/git-study/:3:0","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"安装 参考链接：https://blog.csdn.net/mukes/article/details/115693833 安装完成后开始菜单如下： ","date":"2022-05-19","objectID":"/git-study/:3:1","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"配置 系统级：Git\\etc\\gitconfig ：Git 安装目录下的 gitconfig 用户级：C:\\Users\\Administrator\\.gitconfig 只适用于当前登录用户的配置 #查看git配置 git config -l #配置用户名 git config --global user.name \"seawave0564\" #配置邮箱 git config --global user.email \"943581833@qq.com\" ","date":"2022-05-19","objectID":"/git-study/:3:2","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"三、Git基本理论 Workspace：工作区，就是你平时存放项目代码的地方 Staging/index：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 ","date":"2022-05-19","objectID":"/git-study/:4:0","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"Git的工作流程 在工作目录中添加、修改文件；比如：新建UserMapper.xml 将需要进行版本管理的文件放入暂存区域；存放：git add. 将暂存区域的文件提交到git仓库。 提交：git commit 因此，git管理的文件有三种状态：已修改（modified），已暂存（staged），已提交（committed） ","date":"2022-05-19","objectID":"/git-study/:4:1","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"四、Git项目搭建 方式一：本地创建仓库 #在当前目录创建一个git目录 git init 此方式需要手动链接远程仓库 git remote add origin https://gitee.com/seawave0564/helloworld.git git push -u origin \"master\" 方式二：远程克隆仓库 在Github/Gitee上创建一个仓库，使用git clone 克隆到本地 ","date":"2022-05-19","objectID":"/git-study/:5:0","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"五、Git文件操作 Git文件的四中状态 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态 #查看指定文件状态 git status [filename] #查看所有文件状态 git status # git add . 添加所有文件到暂存区 # git commit -m \"消息内容\" 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 在主目录下建立\".gitignore\"文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 ","date":"2022-05-19","objectID":"/git-study/:6:0","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["学习笔记"],"content":"六、Git分支 分支相关常用命令： # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 合并指定分支到当前分支 $ git merge [branch] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2022-05-19","objectID":"/git-study/:7:0","tags":["git"],"title":"Git食用教程","uri":"/git-study/"},{"categories":["折腾记录"],"content":"在VirtualBox中安装MacOS ","date":"2022-05-13","objectID":"/vb-mac/:1:0","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["折腾记录"],"content":"前言 博主环境如下： 宿主机：WINDOWS 10 H1H2 VirtualBox版本：6.1.34 虚拟机设置如下： 内存：4096MB 处理器：数量4，运行峰值100% 显存：128MB USB设备：USB 3.0 其他：默认 环境无须一样，正常来说更高版本不会出现兼容性问题（不是绝对）。 ","date":"2022-05-13","objectID":"/vb-mac/:1:1","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["折腾记录"],"content":"第一步：下载镜像 可以在https://sysin.org/blog/macOS/ 下载iso镜像，各个版本都有。 此处感谢GitHub netgc 大佬的收录与整理，非常感谢！捐赠地址 选择你需要的版本下载即可。 ","date":"2022-05-13","objectID":"/vb-mac/:1:2","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["折腾记录"],"content":"第二步：创建虚拟机 磁盘大小和内存大小按需设置。但是不可太小。 以macOS Big Sur为例 内存大小建议4GB以上，磁盘大小必须大于40GB！！ 接下来，载入你下载的镜像 选择创建的虚拟机-点击属性=点击存储-点击右下角绿色加号添加虚拟光盘-选择你的镜像（未注册先注册） ","date":"2022-05-13","objectID":"/vb-mac/:1:3","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["折腾记录"],"content":"第三步：配置环境 cd “C:\\Program Files\\Oracle\\VirtualBox\\” VBoxManage.exe modifyvm \"macOS\" --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff VBoxManage setextradata \"macOS\" \"VBoxInternal/Devices/efi/0/Config/DmiSystemProduct\" \"iMac19,1\" VBoxManage setextradata \"macOS\" \"VBoxInternal/Devices/efi/0/Config/DmiSystemVersion\" \"1.0\" VBoxManage setextradata \"macOS\" \"VBoxInternal/Devices/efi/0/Config/DmiBoardProduct\" \"Mac-AA95B1DDAB278B95\" VBoxManage setextradata \"macOS\" \"VBoxInternal/Devices/smc/0/Config/DeviceKey\" \"ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc\" VBoxManage setextradata \"macOS\" \"VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC\" 1 VBoxManage setextradata \"macOS\" \"VBoxInternal2/EfiGraphicsResolution\" \"1440x900\" 请逐行运行命令，其中第一行为你virtualbox主程序路径。“MacOS\"为虚拟机的名字 不确定名字的话输入 VBoxManage list vms查看，输错了会导致后面开机进不了界面，重新输对一次就可以了,无需重新安装。 ","date":"2022-05-13","objectID":"/vb-mac/:1:4","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["折腾记录"],"content":"第四步：进入系统 启动虚拟机后会进入命令行，我们输入exit退出命令行。 依次选择：Boot Maintenance Mannager-Boot From File 选择： 依次进入目录：System-Library-CoreServices 选择boot.efi后单击回车，等待一段时间后即可进入安装页。 ","date":"2022-05-13","objectID":"/vb-mac/:1:5","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["折腾记录"],"content":"第五步：安装MAC OS 进入系统后选择语言： 中国人自然选择中文。 选择磁盘工具。 选中磁盘后，点击抹掉按钮，文件系统默认即可。系统会自动格式化磁盘。（这一步选择磁盘时务必注意你选择的磁盘是否是你在虚拟机给mac创建的磁盘，大小\u003e40GB） 完成后点击右上角磁盘工具，退出磁盘工具。 选择第二项，安装macOS 同意许可后选择创建的磁盘。单机继续。然后等待 继续等待。。。 ","date":"2022-05-13","objectID":"/vb-mac/:1:6","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["折腾记录"],"content":"步骤六：进入系统 安装完成后即可进入系统： enjoy it！ ","date":"2022-05-13","objectID":"/vb-mac/:1:7","tags":["虚拟机"],"title":"VirtualBox安装MacOS虚拟机","uri":"/vb-mac/"},{"categories":["学习笔记"],"content":"Docker使用教程 ","date":"2022-05-01","objectID":"/docker-study/:0:0","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"Docker概述 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像 中，然后发布到任何流行的 Linux 或Windows 操作系统的机器上，也可以实现虚拟化 。容器是完全使用沙箱 机制，相互之间不会有任何接口。 Q：为什么会出现？ A：环境管理复杂，云计算时代的到来，虚拟化手段的变化，LXC的移动性 GitHub开源地址：https://github.com/docker/docker-ce 官方文档：https://docs.docker.com/ ","date":"2022-05-01","objectID":"/docker-study/:1:0","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"名词解释： **镜像（image）：**是一个只读模板，含创建Docker容器的说明，它与操作系统的安装光盘有点像 容器（Container）：镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 Docker 面向对象 容器 对象 镜像 类 ","date":"2022-05-01","objectID":"/docker-study/:1:1","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"在 Ubuntu20.4 上安装Dcoker与卸载 tips：在其他系统环境中可能有所不同，仅供参考 ","date":"2022-05-01","objectID":"/docker-study/:2:0","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"安装 更新apt包索引并安装包以允许apt通过 HTTPS 使用存储库： sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 添加 Docker 的官方 GPG 密钥： curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 安装docker 引擎 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io ","date":"2022-05-01","objectID":"/docker-study/:2:1","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"卸载 卸载 Docker 引擎、CLI 和 Containerd 软件包： sudo apt-get purge docker-ce docker-ce-cli containerd.io 主机上的映像、容器、卷或自定义配置文件不会自动删除。要删除所有映像、容器和卷： sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd ","date":"2022-05-01","objectID":"/docker-study/:2:2","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"配置镜像加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://4gn8fwxf.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2022-05-01","objectID":"/docker-study/:2:3","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"Docker常用命令 ","date":"2022-05-01","objectID":"/docker-study/:3:0","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"镜像命令 docker images 查看本地镜像 seawave@seawave:~$ sudo docker images [sudo] password for seawave: REPOSITORY TAG IMAGE ID CREATED SIZE mysql latest 826efd84393b 3 weeks ago 521MB redis latest 7614ae9453d1 3 months ago 113MB #解释 REPOSITORY 镜像的仓库源 TAG 镜像标签 IMAGE ID 镜像id CREATED 创建的时间 SIZE 镜像的大小 #可选项 -a, --all #列出所有镜像 -q, --quiet #只显示镜像的id docker search 搜索远程镜像 seawave@seawave:~$ sudo docker search mysql [sudo] password for seawave: NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 12353 [OK] mariadb MariaDB Server is a high performing open sou… 4756 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 916 [OK] percona Percona Server is a fork of the MySQL relati… 572 [OK] #可选项 --filter seawave@seawave:~$ sudo docker search mysql --filter=stars=3000 #只显示星标数大于3000的镜像 docker pull 下载镜像 seawave@seawave:~$ sudo docker pull hello-world:tag Using default tag: latest latest: Pulling from library/hello-world Digest: sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60f Status: Image is up to date for hello-world:latest docker.io/library/hello-world:latest #可选项 :tag：下载版本 默认latest（最新版本） docker rmi 删除镜像 seawave@seawave:~$ sudo docker rmi hello-world Untagged: hello-world:latest Untagged: hello-world@sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60f Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412 Deleted: sha256:e07ee1baac5fae6a26f30cabfe54a36d3402f96afda318fe0a96cec4ca393359 seawave@seawave:~$ #可选项 -f 镜像id1..镜像id2 #强制删除指定镜像id ","date":"2022-05-01","objectID":"/docker-study/:3:1","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"容器命令 docker run 创建容器并运行 docker run [可选参数] [镜像id] #参数说明 --name=\"name\" 容器名字 -d #后台方式运行 -it #用交互方式运行，进入容器查看内容 docker run -it centos /bin/bash #退出并停止：exit 退出继续运行:Ctrl+P+Q -P #指定随机端口运行 -p #指定端口运行 --rm #t docker ps 查看容器 seawave@seawave:~$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b8434de9fcf7 portainer/portainer \"/portainer\" About an hour ago Up About an hour 0.0.0.0:9000-\u003e9000/tcp, :::9000-\u003e9000/tcp prtainer-test #可选参数 -a #列出所有容器，包括未运行的 -n #列出指定数量容器 -q #只显示容器编号 docker rm 删除容器 seawave@seawave:~$ sudo docker rm 5cf 5cf #可选项 docker rm -f $(docker ps -aq) #删除所有容器 启动与停止容器 docker start id #启动容器 docker restart id #重启容器 docker stop id #停止当前容器 docker kill id #强制停止当前容器 ","date":"2022-05-01","objectID":"/docker-study/:3:2","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"其他命令 docker logs 查看日志 docker logs #查看日志 -f #跟踪日志输出 -t #显示时间戳 --tail #设定显示日志条数 docker exec进入正在运行的容器 #方式一:打开一个新终端 docker exec -it 容器id /bin/bash #方式二：使用正在执行的终端 docker attach 容器id /bin/bash docker cp 复制文件 docker cp 容器ID:/home/test.java /home # 容器id:容器内部路径 主机路径 docker commit 保存快照 docker commit -a \"seawave\" -m \"add file\" 容器id #-a:作者名;-m:提交信息 #此命令可以将当前容器打包为一个镜像，并且保留所做的修改（保存快照） ","date":"2022-05-01","objectID":"/docker-study/:3:3","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"数据卷 通过数据卷技术可以将容器内部目录与本机目录进行绑定，实现在容器外更改容器内部文件 ","date":"2022-05-01","objectID":"/docker-study/:4:0","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"通过-v命令进行绑定 docker run -it -v /home/test:/home centos /bin/bash #将容器/home目录映射到宿主机/home/test目录下 实战：Mysql持久化 #获取镜像 docker pull mysql:5.7 #运行容器 注意点：mysql启动时需要配置密码！ -e MYSQL_ROOT_PASSWORD=my-secret-pw docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=zgq123 --name mysql01 mysql:5.7 具名挂载 docker run -d -P --name nginx-test -v juming-nginx:/etc/nginx nginx 所有docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxxx/_data下 卷权限 通过ro/rw改变权限，当权限为ro时，只可从宿主机改变。 docker run -d -P --name nginx-test -v juming-nginx:/etc/nginx:ro nginx#只读 docker run -d -P --name nginx-test -v juming-nginx:/etc/nginx:fw nginx#读写 ","date":"2022-05-01","objectID":"/docker-study/:4:1","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"查看卷 docker volume [create/inspect/ls/prune/rm] create 创建卷 inspect 卷id ：查看卷信息 ls ：查看卷列表 rm：移除卷 ","date":"2022-05-01","objectID":"/docker-study/:4:2","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"数据卷容器 可以实现不同容器间共享数据 docker run -it --name centos02 --volumers-from centos01 centos ","date":"2022-05-01","objectID":"/docker-study/:4:3","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"DockerFile ","date":"2022-05-01","objectID":"/docker-study/:5:0","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"指令 FROM：基础镜像 MAINTAINER：作者，姓名+邮箱 RUN ：镜像构建时的命令 ADD：添加内容 WORKDIR：镜像工作目录 VOLUME：挂载目录 EXPOST：保留端口配置 CMD：指定容器启动时要运行的命令 ENTRYPOINT：指定容器启动时要运行的命令，可以追加命令 ","date":"2022-05-01","objectID":"/docker-study/:5:1","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"实战测试 实战一：在ubuntu镜像中添加vim和net-tools DockerHub中99%的镜像都是从scratch基础镜像构建而来。 编写dockerfile文件： 执行构建命令： docker build -f dockerfile -t myubuntu:1.0 . #tips:最后有个点 实战儿：在unbuntu中添加tomcat并配置环境 编写Dockerfile文件 FROM ubuntu MAINTAINER seawave\u003c943581833@qq.com\u003e ADD jdk-8u151-linux-x64.tar.gz /usr/local/ ADD apache-tomcat-9.0.62.tar.gz /usr/local/ RUN apt update RUN apt install -y vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_151 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.62 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.62 ENV PATH $PATH:$JAVA_HOME/bin:CATALINA_HOME/lib:CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.62/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.62/logs 执行build命令 sudo docker build -t diytomcat . 运行生成的镜像 docker run -it -p 9090:8080 --name mytomcat01 -v /home/seawave/build/tomcat/webapps:/usr/local/apache-tomcat-9.0.62/webapps/ -v /home/seawave/build/tomcat/log:/usr/local/apache-tomcat-9.0.62/logs diytomcat /bin/bash ","date":"2022-05-01","objectID":"/docker-study/:5:2","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"发布镜像到DockerHub 首先登录自己的docker账号 docker login #按照提示输入账号密码即可 上传镜像 docker push 容器id ","date":"2022-05-01","objectID":"/docker-study/:5:3","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"Docker网络 首先我们创建一个tomcat容器，发现他的网卡信息如下： eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 5048 bytes 9099495 (8.6 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3543 bytes 243850 (238.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我们尝试用宿主机ping容器的IP地址172.17.0.2： root@seawave:/home/seawave/build/tomcat/webapps# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.035 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.035 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.036 ms 可以ping通，说明宿主机和容器是互通的。 查看宿主机网卡信息发现： root@seawave:/home/seawave/build/tomcat/webapps# ifconfig docker0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:4fff:feb9:d6b9 prefixlen 64 scopeid 0x20\u003clink\u003e ether 02:42:4f:b9:d6:b9 txqueuelen 0 (Ethernet) RX packets 55332 bytes 3613977 (3.6 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 105758 bytes 166228443 (166.2 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 宿主机用于桥接容器的虚拟网卡和容器ip地址在同一网段 ","date":"2022-05-01","objectID":"/docker-study/:6:0","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"容器互联 在创建容器时可以使用 –link参数指定需要互联的容器 docker run -d -P --name tomcat02 --link tomcat01 tomcat 此时在tomcat2中可以ping通tomcat01. ","date":"2022-05-01","objectID":"/docker-study/:6:1","tags":["Java"],"title":"Docker使用教程","uri":"/docker-study/"},{"categories":["学习笔记"],"content":"Swagger使用教程 ","date":"2022-04-29","objectID":"/swagger-study/:1:0","tags":["Java"],"title":"Swagger使用教程","uri":"/swagger-study/"},{"categories":["学习笔记"],"content":"安装 \u003c!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e 注意：swagger 2.9.2仅支持springboot2.5.6以下版本！ 由于swagger已停止更新，springboot2.5.6之后请使用springdoc代替swagger！！ \u003cdependency\u003e \u003cgroupId\u003eorg.springdoc\u003c/groupId\u003e \u003cartifactId\u003espringdoc-openapi-ui\u003c/artifactId\u003e \u003cversion\u003e1.6.8\u003c/version\u003e \u003c/dependency\u003e 同时更新swagger-ui： \u003cdependency\u003e \u003cgroupId\u003eorg.webjars\u003c/groupId\u003e \u003cartifactId\u003eswagger-ui\u003c/artifactId\u003e \u003cversion\u003e4.10.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-29","objectID":"/swagger-study/:1:1","tags":["Java"],"title":"Swagger使用教程","uri":"/swagger-study/"},{"categories":["学习笔记"],"content":"测试 导入依赖后即可访问http://127.0.0.1:8080/swagger-ui.html查看接口文档。 ","date":"2022-04-29","objectID":"/swagger-study/:1:2","tags":["Java"],"title":"Swagger使用教程","uri":"/swagger-study/"},{"categories":["学习笔记"],"content":"配置swagger ","date":"2022-04-29","objectID":"/swagger-study/:2:0","tags":["Java"],"title":"Swagger使用教程","uri":"/swagger-study/"},{"categories":["学习笔记"],"content":"配置首页信息 @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket SwaggerConfigs(){ return new Docket(DocumentationType.SWAGGER_2).apiInfo(getApiInfo()); } public ApiInfo getApiInfo(){ Contact contact = new Contact(\"\", \"\", \"\"); return new ApiInfo( \"seawave api\", \"人生无常大肠包小肠\", \"2.0v\", \"http://www.seawave..top\", contact, \"Apache 2.0\", \"http://www.apache.org/licenses/LICENSE-2.0\", new ArrayList()); } } ","date":"2022-04-29","objectID":"/swagger-study/:2:1","tags":["Java"],"title":"Swagger使用教程","uri":"/swagger-study/"},{"categories":["学习笔记"],"content":"配置扫描接口 通过apis指定需要扫描的接口 public Docket SwaggerConfigs(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(getApiInfo()) .select() .apis() //.......... .build(); } 可选参数有： //RequestHandlerSelectors 配置要扫描的接口\r//.basePackage 扫描指定的包\r//.withClassAnnotation 扫描类上的注解\r//.withMethodAnnotation 扫描包上的注解\r 通过path路径来指定要扫描的接口 @Bean public Docket SwaggerConfigs(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(getApiInfo()) .select() //RequestHandlerSelectors 配置要扫描的接口 //.basePackage 扫描指定的包 //.withClassAnnotation 扫描类上的注解 //.withMethodAnnotation 扫描包上的注解 .paths(PathSelectors.ant(\"com/seawave/**\")) .build(); } ","date":"2022-04-29","objectID":"/swagger-study/:2:2","tags":["Java"],"title":"Swagger使用教程","uri":"/swagger-study/"},{"categories":["学习笔记"],"content":"配置API文档分组 .groupName(\"小组1\") @Bean public Docket docket1(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"小组1\"); } @Bean public Docket docket2(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"小组2\"); } @Bean public Docket docket3(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"小组3\"); } ","date":"2022-04-29","objectID":"/swagger-study/:2:3","tags":["Java"],"title":"Swagger使用教程","uri":"/swagger-study/"},{"categories":["学习笔记"],"content":"什么是Redis? 在Web应用发展的初期，那时关系型数据库受到了较为广泛的关注和应用，原因是因为那时候Web站点基本上访问和并发不高、交互也较少。而在后来，随着访问量的提升，使用关系型数据库的Web站点多多少少都开始在性能上出现了一些瓶颈，而瓶颈的源头一般是在磁盘的I/O上。而随着互联网技术的进一步发展，各种类型的应用层出不穷，这导致在当今云计算、大数据盛行的时代，对性能有了更多的需求，主要体现在以下四个方面： 低延迟的读写速度：应用快速地反应能极大地提升用户的满意度 支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量 大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理 庞大运营成本的考量：IT部门希望在硬件成本、软件成本和人力成本能够有大幅度地降低 为了克服这一问题，NoSQL应运而生，它同时具备了高性能、可扩展性强、高可用等优点，受到广泛开发人员和仓库管理人员的青睐。 Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性： 基于内存运行，性能高效 支持分布式，理论上可以无限扩展 key-value存储系统 开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached 这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。 ","date":"2022-04-04","objectID":"/redis-study/:1:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"NoSQL概述 ","date":"2022-04-04","objectID":"/redis-study/:2:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"什么要用Nosql NoSQL有如下优点：易扩展 ，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。 ","date":"2022-04-04","objectID":"/redis-study/:2:1","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"NoSQL分类 KV键值对： 新浪：Redis 美团：Redis+Tair 阿里、百度：Redis+memecache 文档型数据库（bson格式和json）： MongoDB： 基于分布式存储的数据库，C++编写。 介于关系型数据库和非关系型数据库中中间产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的数据库。 列存储数据库： HBase 分布式文件系统 图关系数据库： 存放图形，放的是关系，比如：朋友圈社交网络，广告推荐！ Neo4J，InfoGid ","date":"2022-04-04","objectID":"/redis-study/:2:2","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Redis 入门 ","date":"2022-04-04","objectID":"/redis-study/:3:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"官网与文档： 官网：https://redis.io 中文网：https://redis.cn Github：https://github.com/redis/redis ","date":"2022-04-04","objectID":"/redis-study/:3:1","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Redis基础语法： select n #切换到第n个数据库 set name zhangsan #设置name的值为zhangsan get name #获取name值 keys * #查看当前数据库所有键 flushdb #清空当前数据库数据 flushall #清空所有数据库所有数据 exists name #查询name键是否存在 move name 1 #将name键和值移动至1号数据库 expire name 10 #设置name键十秒后过期 ttl name #查询name键所剩时间 type name #查询name的数据类型 ","date":"2022-04-04","objectID":"/redis-study/:3:2","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Redis-Key： String append name \"hello\" #向name追加字符hello strlen name #查询name长度 set name 30 \"xiaoming\" #设置name的值为xiaoming并设置过期时间为30妙 setnx name xiaoming #如果不存在name键则设置name为xiaoming mset k1 v1 k2 v2 k3 v3 #设置多个键值对 set user:1{name:zhangsan,age:3} #设置一个user:1对象值为json字符串 List 在redis里面，List可以作为栈、队列、阻塞队列！ Lpush list one #将one放入list（左侧） Lrange list 0 -1 #取出全部的值 Lrange list 0 1 #取出下标从0到1所有值 Rpush list right #将right放入list（右侧） Lpop list #移除list的第一个元素 Rpop list #移除list的最后一个元素 lindex list 1 #通过下标获取list中的某一个值 Llen list #返回列表的长度 lrem list 2 one #移除2个list中的one值（存在数据重复的情况下） ltrim list 1 2 #截取下标1至2的数据 rpoplpush list mylist#移除列表最后一个元素并将其移到mylist中 lset list 0 x #将list中下标为0的位置替换为x existe list #判断这个列表是否存在 linsert list before \"world\" \"other\" #在other之前插入world eg:hello world ==\u003e hello other world Set set中的值不能重复！ sadd myset \"hello\" #添加一个值为hello smembers myset #获取所有值 sismember myset \"hello\" #判断set集合中是否存在hello scard myset #获取set集合中元素个数 srem myset \"hello\" #移除set集合中值为hello的元素 srandmember myset #随机获取集合中的元素 spop myset #随机删除集合中的元素 smove myset myset2 \"hello\"#将hello移动到指定set集合 sdiff set1 set2 #查询set1和set2的差集 sinter set1 set2 #查询set1和set2交集 sunion set1 set2 #查询set1和set2的并集 Hash（键值对） Map集合，Key-Map集合，值是一个map集合 hset myhash field1 value1 #set一个key为field1,value的键值对 hmset myhash field2 value1 field2 value2 #set多个键值对 hmget myhash field1 field2 #获取myhashi中的多个键值对 hgetall myhash #获取myhash中全部键值对 hdel myhash filed #删除myhash中键为filed的键值对 hlen myhash #获取myhash中元素个数 hexists myhash field1 #判断hash中指定字段是否存在 hkeys myhash #获取myhash中所有的key hvals myhash #获取myhash中所有的value haset myhash field3 value3 #添加一个键值对 hsetrnx myhash filed4 value4 #如果不存在则设置一个值 Zset zadd myset 1 one #添加一个值权重为1 zadd myset 2 two 3 three #添加多个值 zrange myset 0 -1 #查询所有值 zrangebyscore salary -inf +inf #根据salary从小到大排序显示 zrem myset value #移除zset中指定元素 zcard myset #获取有序集合中的元素个数 zcount myset 1 3 #获取指定区间数量 ","date":"2022-04-04","objectID":"/redis-study/:3:3","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"事务 ","date":"2022-04-04","objectID":"/redis-study/:4:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"模拟事务 Redis 事务本质：一组命令的集合 开启事务 multi 命令入队 执行事务 exec 锁：Redis可以实现乐观锁 正常执行事务 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e get k1 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e exec 1) OK 2) OK 3) \"v1\" 4) OK 放弃事务：Discard 编译型异常： 代码有问题，比如语法错误，事务中所有命令都不会执行 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e setget k2 v2 (error) ERR unknown command `setget`, with args beginning with: `k2`, `v2`, 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e exec (error) EXECABORT 运行时异常 其他命令可以正常执行，错误命令抛出异常 127.0.0.1:6379\u003e set k1 \"v1\" OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e incr k1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e exec 1) (error) ERR value is not an integer or out of range 2) OK 3) \"v2\" ","date":"2022-04-04","objectID":"/redis-study/:4:1","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"监控 悲观锁： 很悲观，什么时候都会出现问题，无论做什么都加锁 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会上锁 Redis监控测试 正常： 127.0.0.1:6379\u003e set money 100 OK 127.0.0.1:6379\u003e set out 0 OK 127.0.0.1:6379\u003e watch money OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY out 20 QUEUED 127.0.0.1:6379\u003e exec 1) (integer) 80 2) (integer) 20 正常执行成功，事务正常结束。 异常情况： 线程一： 127.0.0.1:6379\u003e set money 100 OK 127.0.0.1:6379\u003e set out 0 OK 127.0.0.1:6379\u003e watch money #监视money OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e Decrby money 20 QUEUED 127.0.0.1:6379\u003e INCRBY out 20 QUEUED 127.0.0.1:6379\u003e 此时不执行exec，模拟线程二插队修改数据： 127.0.0.1:6379\u003e get money \"100\" 127.0.0.1:6379\u003e set money 100 #线程二修改money OK 127.0.0.1:6379\u003e 线程一执行exec： 127.0.0.1:6379\u003e exec (nil) ","date":"2022-04-04","objectID":"/redis-study/:4:2","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Jedis Jedis是Redis官方推荐的java链接开发工具，使用java操作Redis。 导入依赖： \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/redis.clients/jedis --\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.2.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 连接测试： Jedis jedis=new Jedis(\"192.168.0.103\",6379); System.out.println(jedis.ping()); 输出： PONG ","date":"2022-04-04","objectID":"/redis-study/:5:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"常用api： String： System.out.println(\"===========增加数据===========\"); System.out.println(jedis.set(\"key1\",\"value1\")); System.out.println(jedis.set(\"key2\",\"value2\")); System.out.println(jedis.set(\"key3\", \"value3\")); System.out.println(\"删除键key2:\"+jedis.del(\"key2\")); System.out.println(\"获取键key2:\"+jedis.get(\"key2\")); System.out.println(\"修改key1:\"+jedis.set(\"key1\", \"value1Changed\")); System.out.println(\"获取key1的值：\"+jedis.get(\"key1\")); System.out.println(\"在key3后面加入值：\"+jedis.append(\"key3\", \"End\")); System.out.println(\"key3的值：\"+jedis.get(\"key3\")); System.out.println(\"增加多个键值对：\"+jedis.mset(\"key01\",\"value01\",\"key02\",\"value02\",\"key03\",\"value03\")); System.out.println(\"获取多个键值对：\"+jedis.mget(\"key01\",\"key02\",\"key03\")); System.out.println(\"获取多个键值对：\"+jedis.mget(\"key01\",\"key02\",\"key03\",\"key04\")); System.out.println(\"删除多个键值对：\"+jedis.del(\"key01\",\"key02\")); System.out.println(\"获取多个键值对：\"+jedis.mget(\"key01\",\"key02\",\"key03\")); jedis.flushDB(); System.out.println(\"===========新增键值对防止覆盖原先值==============\"); System.out.println(jedis.setnx(\"key1\", \"value1\")); System.out.println(jedis.setnx(\"key2\", \"value2\")); System.out.println(jedis.setnx(\"key2\", \"value2-new\")); System.out.println(jedis.get(\"key1\")); System.out.println(jedis.get(\"key2\")); System.out.println(\"===========新增键值对并设置有效时间=============\"); System.out.println(jedis.setex(\"key3\", 2, \"value3\")); System.out.println(jedis.get(\"key3\")); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(jedis.get(\"key3\")); System.out.println(\"===========获取原值，更新为新值==========\"); System.out.println(jedis.getSet(\"key2\", \"key2GetSet\")); System.out.println(jedis.get(\"key2\")); System.out.println(\"获得key2的值的字串：\"+jedis.getrange(\"key2\", 2, 4)); List： jedis.lpush(\"collections\", \"ArrayList\", \"Vector\", \"Stack\", \"HashMap\", \"WeakHashMap\", \"LinkedHashMap\"); jedis.lpush(\"collections\", \"HashSet\"); jedis.lpush(\"collections\", \"TreeSet\"); jedis.lpush(\"collections\", \"TreeMap\"); System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部 System.out.println(\"collections区间0-3的元素：\"+jedis.lrange(\"collections\",0,3)); System.out.println(\"===============================\"); // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈 System.out.println(\"删除指定元素个数：\"+jedis.lrem(\"collections\", 2, \"HashMap\")); System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1)); System.out.println(\"删除下表0-3区间之外的元素：\"+jedis.ltrim(\"collections\", 0, 3)); System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1)); System.out.println(\"collections列表出栈（左端）：\"+jedis.lpop(\"collections\")); System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1)); System.out.println(\"collections添加元素，从列表右端，与lpush相对应：\"+jedis.rpush(\"collections\", \"EnumMap\")); System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1)); System.out.println(\"collections列表出栈（右端）：\"+jedis.rpop(\"collections\")); System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1)); System.out.println(\"修改collections指定下标1的内容：\"+jedis.lset(\"collections\", 1, \"LinkedArrayList\")); System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1)); System.out.println(\"===============================\"); System.out.println(\"collections的长度：\"+jedis.llen(\"collections\")); System.out.println(\"获取collections下标为2的元素：\"+jedis.lindex(\"collections\", 2)); System.out.println(\"===============================\"); jedis.lpush(\"sortedList\", \"3\",\"6\",\"2\",\"0\",\"7\",\"4\"); System.out.println(\"sortedList排序前：\"+jedis.lrange(\"sortedList\", 0, -1)); System.out.println(jedis.sort(\"sortedList\")); System.out.println(\"sortedList排序后：\"+jedis.lrange(\"sortedList\", 0, -1)); Hash： map.put(\"key1\",\"value1\"); map.put(\"key2\",\"value2\"); map.put(\"key3\",\"value3\"); map.put(\"key4\",\"value4\"); //添加名称为hash（key）的hash元素 jedis.hmset(\"hash\",map); //向名称为hash的hash中添加key为key5，value为value5元素 jedis.hset(\"hash\", \"key5\", \"value5\"); System.out.println(\"散列hash的所有键值对为：\"+jedis.hgetAll(\"hash\"));//return Map\u003cString,String\u003e System.out.println(\"散列hash的","date":"2022-04-04","objectID":"/redis-study/:5:1","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Jedis事务： Jedis jedis = new Jedis(\"192.168.0.103\", 6379); System.out.println(jedis.ping()); JSONObject json =new JSONObject(); json.put(\"name\",\"seawave\"); json.put(\"hello\",\"world\"); String result = json.toJSONString(); Transaction multi = jedis.multi(); try { multi.set(\"user1\",result); multi.set(\"user2\",result); int i= 1/0; multi.exec(); } catch (Exception e) { e.printStackTrace(); multi.discard(); } finally { System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close(); } } 结果： java.lang.ArithmeticException: 除以零 at com.seawave.TestTx.main(TestTx.java:21) null null ","date":"2022-04-04","objectID":"/redis-study/:5:2","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"SpringBoot整合： ","date":"2022-04-04","objectID":"/redis-study/:6:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"简单测试案例 导入依赖:idea可快速导入 配置链接：在application.yml中配置端口、ip等信息。 redis:host:127.0.0.1port:6379 测试 @Test void contextLoads() { //opsForValue 操作字符串 类似于String //opsForList //..... //除了基本的操作，我们常用的方法可以通过redisTemplate直接操作比如事务、基本的CRUD redisTemplate.opsForValue().set(\"name\",\"seawave\"); System.out.println(redisTemplate.opsForValue().get(\"name\")); 输出：seawave ","date":"2022-04-04","objectID":"/redis-study/:6:1","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Redis.conf文件解析 网络 bind 127.0.0.1 #绑定的IP，用于控制访问 protected-mode yes/no #保护模式 port 6379 #访问端口 通用 daemonize no/yes #以守护进程方式运行 pidfile /var/run/redis_6379.pid #如果以守护进程方式运行我们需要指定pid文件 loglevel [debug/verbose/notice/warning] #日志级别 logfile \"\" #日志文件路径 databases #数据库数量，默认16 always-show-logo yes/no #是否显示logo 快照 持久化：在规定的时间内，执行了多少次操作，则会持久化到文件.rdb/.aof save 900 1 #如果900秒内，至少有一个key进行了修改，就进行持久化操作 save 300 10 #如果300秒内，至少有10个key进行了修改，就进行持久化操作 save 60 10000 #如果60秒内，至少有10000个key进行了修改，就进行持久化操作 stop-writes-on-bgsave-error yes #如果持久化出错，是否继续工作 rdbcompression yes/no #是否压缩.rdb文件 rdbchecksum yes/no #保存.rdb文件时进行错误校验 dir ./ #.rdb文件保存目录 安全 config get requirepass #获取redis密码 config set requirepass \"123456\" #设置redis的密码 限制 maxclients 10000 #设置能连接上redis的最大客户端数量 maxmemory \u003cbytes\u003e #设置redis最大内存占用 maxmemory-policy noeviction \u003c!--1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key 3、volatile-random：随机删除即将过期key 4、allkeys-random：随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误--\u003e AOF持久化 appendonly no/yes #是否开启aof持久化，默认为rdb模式 appendfilename \"appendonly.aof\" #aof持久化文件名 appendfsync everysec/no/always #每秒执行一次同步/不同步/每次修改同步 ","date":"2022-04-04","objectID":"/redis-study/:7:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Redis持久化 Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化功能。 ","date":"2022-04-04","objectID":"/redis-study/:8:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"RDB(Redis DataBase) RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。 AOF(AppendOnly File) 每当有一个修改数据库的命令被执行时，服务器就将命令写入到 appendonly.aof 文件中，该文件存储了服务器执行过的所有修改命令，因此，只要服务器重新执行一次 .aof 文件，就可以实现还原数据的目的，这个过程被形象地称之为“命令重演”。 1) 写入机制 Redis 在收到客户端修改命令后，先进行相应的校验，如果没问题，就立即将该命令存追加到 .aof 文件中，也就是先存到磁盘中，然后服务器再执行命令。这样就算遇到了突发的宕机情况情况，也只需将存储到 .aof 文件中的命令，进行一次“命令重演”就可以恢复到宕机前的状态。 在上述执行过程中，有一个很重要的环节就是命令的写入，这是一个 IO 操作。Redis 为了提升写入效率，它不会将内容直接写入到磁盘中，而是将其放到一个内存缓存区（buffer）中，等到缓存区被填满时才真正将缓存区中的内容写入到磁盘里。 2) 重写机制 Redis 在长期运行的过程中，aof 文件会越变越长。如果机器宕机重启，“重演”整个 aof 文件会非常耗时，导致长时间 Redis 无法对外提供服务。因此就需要对 aof 文件做一下“瘦身”运动。 为了让 aof 文件的大小控制在合理的范围内，Redis 提供了 AOF 重写机制，手动执行BGREWRITEAOF命令 ","date":"2022-04-04","objectID":"/redis-study/:8:1","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"发布订阅 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 序号 命令及描述 1 [PSUBSCRIBE pattern pattern …] 订阅一个或多个符合给定模式的频道。 2 [PUBSUB subcommand argument [argument …]] 查看订阅与发布系统状态。 3 PUBLISH channel message 将信息发送到指定的频道。 4 [PUNSUBSCRIBE pattern [pattern …]] 退订所有给定模式的频道。 5 [SUBSCRIBE channel channel …] 订阅给定的一个或多个频道的信息。 6 [UNSUBSCRIBE channel [channel …]] 指退订给定的频道。 ","date":"2022-04-04","objectID":"/redis-study/:9:0","tags":["Java"],"title":"初识Redis","uri":"/redis-study/"},{"categories":["学习笔记"],"content":"Junit ","date":"2022-03-30","objectID":"/junit-study/:0:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"简介 单元测试工具（方法） 常用于白盒测试 官网https://junit.org/junit4/ ","date":"2022-03-30","objectID":"/junit-study/:1:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"导入 创建一个普通Maven项目 在pom.xml中引入依赖 Maven \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 注：junit4.11以上版本不在包含hamcrest，需要手动安装 \u003c!-- https://mvnrepository.com/artifact/org.hamcrest/hamcrest-core --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.hamcrest\u003c/groupId\u003e \u003cartifactId\u003ehamcrest-core\u003c/artifactId\u003e \u003cversion\u003e1.3\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e ","date":"2022-03-30","objectID":"/junit-study/:2:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"覆盖测试 对应代码 public double getData(int a, int b) { double x = 0, y = 0, z = 0; if (a \u003e 5 \u0026\u0026 b \u003e 10) { x = Math.pow(a, 2) * b; return x; } else { if (b == 0 \u0026\u0026 a \u003e 0) { y = Math.sqrt(a); return y; } else { z = Math.pow(a + b, 5); return z; } } } ","date":"2022-03-30","objectID":"/junit-study/:3:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"条件覆盖 @Test public void test1(){ System.out.println(getData(6, 12)); //R==\u003e6^2*12=432 A-B System.out.println(getData(1,2)); // R==\u003e(3+2)^5=243.0 A-C-D System.out.println(getData(4,0)); // R==\u003esqrt(4)= 2 A-C-E } ","date":"2022-03-30","objectID":"/junit-study/:3:1","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"断言 ","date":"2022-03-30","objectID":"/junit-study/:4:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"常用匹配方法 //要求所有的条件都要通过测试才算成功 assertThat(\"hello world\", allOf(startsWith(\"helloo\"), containsString(\"world\"))); //false //如果接下来的所有条件只要有一个成立则测试通过 assertThat(\"hello world\", anyOf(startsWith(\"hello\"), containsString(\"worldd\"))); //true //anything匹配符表明无论什么条件，永远为true assertThat( \"hello world\", is( \"hello\" ) ); //true //is表明如果前面待测的object等于后面给出的object assertThat( \"hello world\", is( \"hello world\") ); //true //not匹配符和is匹配符正好相反，表明如果前面待测的object不等于后面给出的object assertThat( \"hello world\", not( \"hello world\") ); //false //判断是否包含字符串 assertThat( \"helloWorld\", containsString( \"hello\" ) ); //true //判断是否以指定字符串结尾 assertThat( \"helloWorld\", endsWith( \"World\" ) ); //true //判断是否以指定字符串开始 assertThat( \"helloWorld\", startsWith( \"hello\" ) ); //true //equalTo匹配符表明如果测试的testedValue等于expectedValue则测试通过 assertThat( \"hello\", equalTo(\"hello\") ); //判断忽略首尾空格时是否相等 assertThat( \"hello\", equalToIgnoringWhiteSpace( \" hello \" ) ); //true //判断列表中是否包含指定项 assertThat(Arrays.asList(\"foo\", \"bar\"), hasItem(\"bar\")); //判断列表中是否包含多项 assertThat(Arrays.asList(\"foo\", \"bar\", \"baz\"), hasItems(\"baz\", \"foo\")) //判断指定对象是否是某个类（包括子类） assertThat(new ArrayList\u003c\u003e(), instanceOf(List.class)); 注意事项： 要注意区分error和failure！！！ failure是指：被测程序的逻辑有错误，得不到预期的值。执行了junit的断言。 error是指：被测程序本身抛出的异常，还没有执行到junit的断言就抛出了异常。 ","date":"2022-03-30","objectID":"/junit-study/:4:1","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"Junit测试类注解 junit4 junit5 特点 @BeforeClass @BeforeAll 在当前类的所有测试方法之前执行。注解在【静态方法】上。 @AfterClass @AfterAll 在当前类中的所有测试方法之后执行。注解在【静态方法】上。 @Before @BeforeEach 在每个测试方法之前执行。注解在【非静态方法】上。 @After @AfterEach 在每个测试方法之后执行。注解在【非静态方法】上。 区别： @AfterClass修饰public static void 、@After修饰public void @AfterClass在一个测试类中只能一个,但是@After可以有多个 @AfterClass只执行一次,是在所有@Test方法执行完成后、@After在每个@Test方法执行完成后都会执行 ","date":"2022-03-30","objectID":"/junit-study/:5:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"@RunnerTest测试运行器 ","date":"2022-03-30","objectID":"/junit-study/:6:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"Junit测试套件 public class JunitTestOne { @Test public void test() { System.out.println(\"测试一。。。\"); } } public class JunitTestTwo { @Test public void test() { System.out.println(\"测试二。。。\"); } } public class JunitTestThree { @Test public void test() { System.out.println(\"测试三。。。\"); } } @RunWith(Suite.class) @Suite.SuiteClasses({ JunitTestOne.class,JunitTestTwo.class ,JunitTestThree.class}) public class AllTests { } 此时执行Alltests会同时执行三个测试方法 ","date":"2022-03-30","objectID":"/junit-study/:7:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"Junit异常测试 例子： @Test(expected = IndexOutOfBoundsException.class) public void test (){ List\u003cString\u003e lists = new ArrayList\u003c\u003e(); lists.get(1); } @expected表达式表示如果方法抛出指定异常则测试通过，以上例子可以通过测试。 ","date":"2022-03-30","objectID":"/junit-study/:8:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"Junit限时测试 例子： @Test(timeout = 1000) public void test (){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } @timeout表达式表示如果方法运行市场超过指定行数则测试不通过，以上案例中使用线程阻塞的方式阻塞线程2000毫秒，超过了规定时间，所以测试不通过。 ","date":"2022-03-30","objectID":"/junit-study/:9:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"Junit参数化测试 步骤： 编写参数化测试类并标注 @RunWith(value = Parameterized.class) 定义公共变量用于设置参数（用例参数，预期值） 编写全参构造方法用于传值 编写一个返回集合的静态类用于传入测试用例值 并标注@Parameters import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; import java.util.Arrays; import java.util.Collection; import static org.hamcrest.CoreMatchers.equalTo; import static org.hamcrest.CoreMatchers.is; import static org.hamcrest.MatcherAssert.assertThat; @RunWith(value = Parameterized.class) public class ParameterizedTest { private int a; private int b; private double expected; // Inject via constructor // for {8, 2, 10}, numberA = 8, numberB = 2, expected = 10 public ParameterizedTest(int numberA, int numberB, double expected) { this.a = numberA; this.b = numberB; this.expected = expected; } // name attribute is optional, provide an unique name for test // multiple parameters, uses Collection\u003cObject[]\u003e @Parameters public static Collection\u003cObject[]\u003e data() { return Arrays.asList(new Object[][]{ {6, 12, 432.0}, {1, 2, 243.0}, {4, 0, 2.0}, }); } @Test public void test_getData() { TestCode testCode = new TestCode(); assertThat(testCode.getData(a, b), equalTo(expected)); } } Junit优先级测试 @FixMethodOrder() 参数：MethodSorters.JVM（按照JVM得到的顺序执行） MethodSorters.NAME_ASCENDING（按照名字顺序） ","date":"2022-03-30","objectID":"/junit-study/:10:0","tags":["Java"],"title":"Junit使用教程","uri":"/junit-study/"},{"categories":["学习笔记"],"content":"MQTT协议简解 MQTT(消息队列遥测传输)是ISO 标准(ISO/IEC PRF 20922)下基于发布 /订阅 范式的消息协议。它工作在 TCP/IP协议族上，是为硬件性能 低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议 ，为此，它需要一个[消息中间件 ](https://baike.baidu.com/item/ 消息中间件 /5899771)。 MQTT是一个基于客户端 -服务器 的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 ","date":"2022-03-17","objectID":"/mqtt-study/:1:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"MQTT的实现方式 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分： （1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）； （2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 ","date":"2022-03-17","objectID":"/mqtt-study/:2:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"MQTT的特点 相互可独立：订阅者之间并不知道对方的存在，而发布者也不知道有多少客户端订阅了自己。 空间可分离：只要订阅者、服务器、发布者连接了网络，那么就不受空间距离限制。 时间可异步：订阅者有时并不能立马收到发布者的消息（比如断网），但是当可以接收时可以继续接收到已经发布的消息。 ","date":"2022-03-17","objectID":"/mqtt-study/:3:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"MQTT客户端与服务端连接过程 首先MQTT客户端将会向服务端发送连接请求。该请求实际上是一个包含有连接请求信息的数据包。这个数据包的官方名称为CONNECT。 MQTT服务端收到客户端连接请求后，会向客户端发送连接确认。同样的，该确认也是一个数据包。这个数据包官方名称为CONNACK。 ","date":"2022-03-17","objectID":"/mqtt-study/:4:0","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"CONNECT报文 在上面的描述中我们看到。MQTT客户端要想连接服务端，首先要向服务端发送CONNECT报文。如果此CONNECT报文的格式或内容不符合MQTT规范，则服务器会拒绝客户端的连接请求。 下图是CONNECT报文所包含的信息内容。 clientId – 客户端ID ClientId是MQTT客户端的标识。MQTT服务端用该标识来识别客户端。因此ClientId必须是独立的。如果两个MQTT客户端使用相同ClientId标识，服务端会把它们当成同一个客户端来处理。通常ClientId是由一串字符所构成的，如上图所示，此示例中的clientID是“client-1”。 cleanSession – 清除会话 cleanSession有两种状态分别为true和false，当设置为true时，服务器将不会确认客户端是否收到消息，也不会保存报文，当设置为false时，服务器发出报文后会等待客户端发送确认报文，如果没有收到确认报文，则会保存报文，等待下次发送。 请注意，如果需要服务端保存重要报文，光设置cleanSession 为false是不够的，还需要传递的MQTT信息QoS级别大于0。 关于QoS的概念，我们会在本教程后续课程中详细讲解。到目前请您务必牢记，如果想让服务器记住重要报文，那么客户端在连接服务端时，需要把cleanSession中设置为false。这一点非常关键，请务必牢记。 **keepAlive – 心跳时间间隔 MQTT服务端运行过程中，当有客户端因为某种原因断开了与服务端的连接，服务端需要实时了解这一情况。KeepAlive （心跳时间间隔）正是用于服务端了解客户端连接情况的目前您只需要记住，KeepAlive用于服务端实时了解客户端是否与其保持连接的情况。 ","date":"2022-03-17","objectID":"/mqtt-study/:4:1","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"CONNACK – 确认连接请求报文 CONNACK报文包括两个信息。一个是returnCode(连接返回码)，另一个是sessionPresent (当前会话)。以下是这两个信息的说明： returnCode – 连接返回码 当服务端收到了客户端的连接请求后，会向客户端发送returnCode(连接返回码)，用以说明连接情况。如果客户端与服务端成功连接，则返回数字“0”。如果未能成功连接，连接返回码将会是一个非零的数值，具体这个数值的含义，请见下表： 返回码 返回码描述 0 成功连接 1 连接被服务端拒绝，原因是不支持客户端的MQTT协议版本 2 连接被服务端拒绝，原因是不支持客户端标识符的编码。 3 连接被服务端拒绝，网络连接已经建立，但MQTT服务不可用。 4 连接被服务端拒绝，原因是用户名或密码无效。 5 连接被服务端拒绝，原因是客户端未被授权连接到此服务端。 sessionPresent – 当前会话 当重要客户端连接服务端时，服务端可能保存着没有得到确认的报文。如果是这样的话，那么客户端在连接服务端时，就会通过sessionPresent来了解服务端是否有之前未能确认的信息。简单来说，sessionpressent携带着是否收到报文的确认信息。 ","date":"2022-03-17","objectID":"/mqtt-study/:4:2","tags":["物联网","协议"],"title":"初识MQTT协议","uri":"/mqtt-study/"},{"categories":["学习笔记"],"content":"什么是Mybatis-plus？ ","date":"2022-03-05","objectID":"/mybatis-plus/:1:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"简介 MyBatis-Plus (opens new window) （简称 MP）是一个 MyBatis (opens new window) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 开源代码：Github [Gitee]https://gitee.com/baomidou/mybatis-plus() 官方文档：https://baomidou.com/pages/24112f/ ","date":"2022-03-05","objectID":"/mybatis-plus/:1:1","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 ","date":"2022-03-05","objectID":"/mybatis-plus/:1:2","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"支持数据库 任何能使用 MyBatis 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。 MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库 ","date":"2022-03-05","objectID":"/mybatis-plus/:1:3","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"第一个使用例子： ","date":"2022-03-05","objectID":"/mybatis-plus/:2:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"数据表结构 ","date":"2022-03-05","objectID":"/mybatis-plus/:2:1","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"配置数据源 spring:datasource:driver-class-name:com.mysql.cj.jdbc.Driverusername:rootpassword:rooturl:jdbc:mysql://localhost:3306/mybatis-plus?useUnicode=true\u0026characterEncoding=utf-8\u0026serverTimezone=GMT%2B8 ","date":"2022-03-05","objectID":"/mybatis-plus/:2:2","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"创建Mapper类 *使用@Repository注解将Mapper注入到spring容器。 @Repository @Mapper public interface UserMapper extends BaseMapper\u003cUser\u003e { } BaseMapper类：mybatis-plus内置类，存放基础sql语句，当我们的查询比较简单时，使用这个类即可快速完成查询。 ","date":"2022-03-05","objectID":"/mybatis-plus/:2:3","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"编写实体类 *此处使用了Lombok注解简化setter/getter方法和构造器 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer id; private String name; private Integer age; private String email; } ","date":"2022-03-05","objectID":"/mybatis-plus/:2:4","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"测试 @SpringBootTest class MybatisPlusApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List\u003cUser\u003e users = userMapper.selectList(null); List\u003cUser\u003e users = userMapper.selectList(null); users.forEach(System.out::println);} } 结果如下 ","date":"2022-03-05","objectID":"/mybatis-plus/:3:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"CRUD ","date":"2022-03-05","objectID":"/mybatis-plus/:4:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"主键生成策略 @TableId注解 public enum IdType { AUTO(0), // 数据库id自增 NONE(1), // 未设置主键 INPUT(2), // 手动输入 ID_WORKER(3), // 默认的全局唯一id UUID(4), // 全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 } ","date":"2022-03-05","objectID":"/mybatis-plus/:4:1","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"自动填充 在实体类中有如下字段 //字段添加填充内容 @TableField(fill = FieldFill.INSERT) private LocalDateTime create_time; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime update_time; @TableField注解：注解填充字段，用于标注需要填充的属性。值为自动填充的触发条件。 编写自定义处理器，实现MetaObjectHandler接口 @Component public class MyHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { this.strictInsertFill(metaObject, \"create_time\", LocalDateTime.class, LocalDateTime.now()); this.strictInsertFill(metaObject, \"update_time\", LocalDateTime.class, LocalDateTime.now()); } @Override public void updateFill(MetaObject metaObject) { this.strictInsertFill(metaObject, \"update_time\", LocalDateTime.class, LocalDateTime.now()); } } 注意标识@Component注解，将自定义处理器注入容器 ","date":"2022-03-05","objectID":"/mybatis-plus/:4:2","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"乐观锁* 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题， 再次更新值测试 悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！ 乐观锁实现方式： 取出记录时，获取当前 version 更新时，带上这个 version 执行更新时， set version = newVersion where version = oldVersion 如果 version 不对，就更新失败 举例： 在表中添加version字段并更新实体类 在实体类的version属性上添加@version注解 @Version private Integer version; 注册组件 ","date":"2022-03-05","objectID":"/mybatis-plus/:4:3","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"查询操作 批量查询 public void testQuery(){ List\u003cUser\u003e users = userMapper.selectBatchIds(Arrays.asList(1,2,3)); users.forEach(System.out::println); } 条件查询 @Test public void testQuery2(){ HashMap\u003cString, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"name\",\"fuck\"); List\u003cUser\u003e users = userMapper.selectByMap(map); users.forEach(System.out::println); } ","date":"2022-03-05","objectID":"/mybatis-plus/:4:4","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"删除操作 和查询无异！！！！！！！！！！！（偷懒） 逻辑删除 物理删除 ：从数据库中直接移除 逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效，类似于回收站！ 测试： 在表中增加字段 deleted 字段 配置application.yml mybatis-plus:global-config:db-config:logic-delete-field:flag# 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)logic-delete-value:1# 逻辑已删除值(默认为 1)logic-not-delete-value:0# 逻辑未删除值(默认为 0) 测试 当我们再次查询时，1号用户将不会被查询到 ","date":"2022-03-05","objectID":"/mybatis-plus/:4:5","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["学习笔记"],"content":"Wrapper：条件构造器 例子： @Test void contextLoads() { // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper .isNotNull(\"name\") .isNotNull(\"email\") .ge(\"age\",12); userMapper.selectList(wrapper).forEach(System.out::println); } @Test void test2(){ // 查询名字狂神说 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.eq(\"name\",\"狂神说\"); User user = userMapper.selectOne(wrapper); 或者 Map System.out.println(user); } @Test void test3(){ // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.between(\"age\",20,30); // 区间 Integer count = userMapper.selectCount(wrapper);// 查询结果数 System.out.println(count); } // 模糊查询 @Test void test5(){ QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); // id 在子查询中查出来 wrapper.inSql(\"id\",\"select id from user where id\u003c3\"); List\u003cObject\u003e objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println); } //测试六 @Test void test6(){ QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); // 通过id进行排序 wrapper.orderByAsc(\"id\"); List\u003cUser\u003e users = userMapper.selectList(wrapper); users.forEach(System.out::println); } ","date":"2022-03-05","objectID":"/mybatis-plus/:5:0","tags":["spring","spring boot","java"],"title":"MyBatis-plus使用教程","uri":"/mybatis-plus/"},{"categories":["折腾记录"],"content":"腾讯企业邮箱 协议 服务器地址 端口号 IMAP(接收) imap.exmail.qq.com 993 SMTP(发送) smtp.exmail.qq.com 465 POP3 pop.exmail.qq.com 995 ","date":"2022-03-05","objectID":"/mail-config/:1:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["折腾记录"],"content":"网易云邮箱 网易163免费邮箱相关服务器信息： 协议 服务器地址 端口号 IMAP(接收) imap.163.com 993 SMTP(发送) smtp.163.com 465/994 POP3 pop.163.com 995 ","date":"2022-03-05","objectID":"/mail-config/:2:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["折腾记录"],"content":"QQ邮箱 QQ邮箱相关服务器信息： 协议 服务器地址 端口号 IMAP(接收) imap.qq.com 993 SMTP(发送) smtp.qq.com 465/587 POP3 pop.163.com 995 **账户名：**您的QQ邮箱账户名 **密码：**您的QQ邮箱密码 ","date":"2022-03-05","objectID":"/mail-config/:3:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["折腾记录"],"content":"Gmail Google邮箱相关服务器信息： 协议 服务器地址 端口号 IMAP(接收) imap.gmail.com 993 SMTP(发送) smtp.gmail.com 465 POP3 pop.163.com 995 完整名称：您的姓名 帐号名、用户名或：您的完整电子邮件地址 密码：您的 Gmail 密码 ","date":"2022-03-05","objectID":"/mail-config/:4:0","tags":["邮箱"],"title":"第三方客户端添加邮箱的相关配置","uri":"/mail-config/"},{"categories":["学习笔记"],"content":"什么是SpringBoot？ Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 简单来说，springboot就是会我们自动配置spring框架，从而简化开发流程。 所以约定大于配置变得尤为重要。 ","date":"2022-03-01","objectID":"/springboot-study/:1:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"构建SpringBoot程序 ","date":"2022-03-01","objectID":"/springboot-study/:2:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"方式一、从官网构建 在以下网站中初始化配置后，下载到本地使用idea导入即可。 https://start.spring.io/ ","date":"2022-03-01","objectID":"/springboot-study/:2:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"方式二、使用idea自带方式构建 在new project窗口中选择Spring initializr，然后初始化配置即可。 tips:在resources目录下修改或新建banner.txt可以修改spring启动时欢迎语 模板: _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ .' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '\u003c `.___\\_\u003c|\u003e_/___.' \u003e'\"\". | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / ======`-.____`-.___\\_____/___.-`____.-'====== `=---=' ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG 效果： ","date":"2022-03-01","objectID":"/springboot-study/:2:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"SpringBoot原理初探 ","date":"2022-03-01","objectID":"/springboot-study/:3:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"1、启动器 spring-boot-starter \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter； ","date":"2022-03-01","objectID":"/springboot-study/:3:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"2、主启动类 默认的主动启动类 //@SpringBootApplication 来标注一个主程序类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class SpringbootApplication { public static void main(String[] args) { //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); } } @SpringBootApplication注解 作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； spring.factories 我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ SpringApplication 这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 ","date":"2022-03-01","objectID":"/springboot-study/:3:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"YAML YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。 YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。 YAML 的配置文件后缀为 .yml，如：application.yml 。 ","date":"2022-03-01","objectID":"/springboot-study/:4:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"基本语法 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#‘表示注释 ","date":"2022-03-01","objectID":"/springboot-study/:4:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"数据类型 YAML 支持以下几种数据类型： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 YAML对象 对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。 也可以使用 key:{key1: value1, key2: value2, …}。 还可以使用缩进表示层级关系； key:child-key:valuechild-key2:value2 YAML数组 - A- B- C YAML 支持多维数组，可以使用行内表示： key:[value1, value2, ...] 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 -- A- B- C 例子 companies:-id:1name:company1price:200W-id:2name:company2price:500W 复合结构 数组和对象可以构成复合结构，例： languages:- Ruby- Perl- Python websites:YAML:yaml.org Ruby:ruby-lang.org Python:python.org Perl:use.perl.org 转换为 json 为： {languages:['Ruby','Perl','Python'],websites:{YAML:'yaml.org',Ruby:'ruby-lang.org',Python:'python.org',Perl:'use.perl.org'}} ","date":"2022-03-01","objectID":"/springboot-study/:4:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"配置文件切换 ","date":"2022-03-01","objectID":"/springboot-study/:5:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"1、多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： #比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了; spring.profiles.active=dev yaml的多文档块 server:port:8081#选择要激活那个环境块spring:profiles:active:prod---server:port:8083spring:profiles:dev#配置环境的名称---server:port:8084spring:profiles:prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ ","date":"2022-03-01","objectID":"/springboot-study/:5:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"2、配置文件加载位置 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 优先级1：项目路径下的config文件夹配置文件 优先级2：项目路径下配置文件 优先级3：资源路径下的config文件夹配置文件 优先级4：资源路径下配置文件 ","date":"2022-03-01","objectID":"/springboot-study/:5:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"使用SpringBoot进行Web开发 ","date":"2022-03-01","objectID":"/springboot-study/:6:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"1、静态资源处理 在springboot中，我们可以使用以下方式处理今天资源。 webjars localhost:8080/webjars/ public，static，/**，resources localhost:8080 优先级 ：resources\u003estatic\u003epublic ","date":"2022-03-01","objectID":"/springboot-study/:6:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"2、模板引擎Thymeleaf 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。 Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本 https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter pom依赖： \u003c!--thymeleaf--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-thymeleaf\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2022-03-01","objectID":"/springboot-study/:6:2","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"3、页面国际化 国际化的作用就是使页面支持多种语言切换，从而使页面国际化！ 编写配置文件 我们在resources资源文件下新建一个i18n目录，存放国际化配置文件 建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！ 然后就行翻译处理，将所需要翻译的文本翻译后填入对应的文本框中 配置目录：在application.properties中配置 spring.messages.basename=i18n.login 配置页面国际化值 去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…} 配置国际化解析 假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！修改一下前端页面的跳转连接： 我们去写一个处理的组件类！ package com.kuang.component; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; //可以在链接上携带区域信息 public class MyLocaleResolver implements LocaleResolver { //解析请求 @Override public Locale resolveLocale(HttpServletRequest request)hailagn { String language = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的 //如果请求链接不为空 if (!StringUtils.isEmpty(language)){ //分割请求参数 String[] split = language.split(\"_\"); //国家，地区 locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) { } } 为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean； @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } 配置登录拦截器 编写拦截器类 public class LoginHandlerInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object loginUser = request.getSession().getAttribute(\"loginUser\"); if(loginUser==null){ request.setAttribute(\"msg\",\"没有权限，请先登录\"); //转发至主页 request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }else{ return true; } } } 实例化拦截器并注入 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/index.html\",\"/\",\"/user/login\",\"/css/**\",\"/img/**\"); } 拦截请求时注意过滤静态资源，拦截静态资源会导致css样式不可用，无法访问请求等状况。 ","date":"2022-03-01","objectID":"/springboot-study/:6:3","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"SpringBoot整合Mybatis 在绝大多数开发场景中，我们都需要通过数据库进行数据的存储，就目前来说，Mybatis是一个比较常用的持久层框架，他能很好的帮助我们的开发，在下面的例子将会说明如何在springboot中整合mybatis。 官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ Maven仓库地址：https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter ","date":"2022-03-01","objectID":"/springboot-study/:7:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"整合案例： 导Mybatis依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.1.1\u003c/version\u003e \u003c/dependency\u003e 配置数据源： spring:datasource:username:rootpassword:root#?serverTimezone=UTC解决时区的报错url:jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC\u0026useUnicode=true\u0026characterEncoding=utf-8driver-class-name:com.mysql.cj.jdbc.Drivertype:com.alibaba.druid.pool.DruidDataSource#Spring Boot 默认是不注入这些属性值的，需要自己绑定#druid 数据源专有配置initialSize:5minIdle:5maxActive:20maxWait:60000timeBetweenEvictionRunsMillis:60000minEvictableIdleTimeMillis:300000validationQuery:SELECT 1 FROM DUALtestWhileIdle:truetestOnBorrow:falsetestOnReturn:falsepoolPreparedStatements:true#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入#如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4jfilters:stat,wall,log4jmaxPoolPreparedStatementPerConnectionSize:20useGlobalDataSourceStat:trueconnectionProperties:druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 创建测试表： 创建实体类： @Data @AllArgsConstructor @NoArgsConstructor public class User { private int number; private String name; private int age; private String sex; } 5.在application.yml中配置mybatis实体类映射： mybatis:type-aliases-package:com.seawave.pojomapper-locations:classpath:mybatis/mapper/*.xml 6.编写UserMapper \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.seawave.mapper.UserMapper\"\u003e \u003c!-- 查询所有用户--\u003e \u003cselect id=\"queryUserList\" resultType=\"com.seawave.pojo.User\"\u003e select * from student \u003c/select\u003e \u003c!-- 根据id查询用户--\u003e \u003cselect id=\"queryUserById\" resultType=\"User\"\u003e select * from student where id = #{id} \u003c/select\u003e \u003c!--添加一个用户--\u003e \u003cinsert id=\"addUser\" parameterType=\"User\"\u003e insert into student (name, age, sex) values (#{name}, #{age}, #{sex}) \u003c/insert\u003e \u003c!-- 更新一个用户--\u003e \u003cupdate id=\"updateUser\" parameterType=\"User\"\u003e update student set name=#{name}, age=#{age}, sex=#{sex}where id =#{id} \u003c/update\u003e \u003c!--删除一个用户--\u003e \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from student where id = #{id} \u003c/delete\u003e \u003c/mapper\u003e 在测试类中测试是否正常连接数据库 @SpringBootTest class Springboot05MybatisApplicationTests { @Autowired UserMapper userMapper; @Test void contextLoads() { for (User user : userMapper.queryUserList()) { System.out.println(user); } } } 成功即可读取到数据库表内容： ","date":"2022-03-01","objectID":"/springboot-study/:7:1","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"拦截器配置模板 @Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { //拦截路径 String[] addPathPatterns = { \"/page/**\",\"/student/**\" }; //排除路径 String[] excludePathPatterns = { \"/student/login\",\"/student/register\" }; registry.addInterceptor(new HandlerController()).addPathPatterns(addPathPatterns).excludePathPatterns(excludePathPatterns); } } ","date":"2022-03-01","objectID":"/springboot-study/:8:0","tags":["spring","spring boot","java"],"title":"初识SpringBoot","uri":"/springboot-study/"},{"categories":["学习笔记"],"content":"Vue快速入门 以下所有代码均可在浏览器直接运行，替换body即可。为了节省空间，里的内容需自行添加。 ","date":"2022-01-05","objectID":"/vue-study/:0:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"1.导入Vue \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\"\u003e\u003c/script\u003e ","date":"2022-01-05","objectID":"/vue-study/:1:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"2.数据绑定 方式一： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{message}} \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"hello,vue!\" } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 方式二： 通过v-bind指令： \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cspan v-bind:title=\"message\"\u003e悬停几秒查看动态绑定\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" } }) \u003c/script\u003e \u003c/body\u003e 经过以上的操作div中的{{message}}的显示内容已经被绑定到了VUE对象中的message属性上，更改message的值即可动态刷新页面中的值。 ","date":"2022-01-05","objectID":"/vue-study/:2:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"3.条件判断 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1 v-if=\"ok==='a'\"\u003eA\u003c/h1\u003e \u003ch1 v-else-if=\"ok==='b'\"\u003eB\u003c/h1\u003e \u003ch1 v-else\u003eC\u003c/h1\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ ok:'a' } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:3:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"4.语句循环 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cli v-for=\"item in items\"\u003e {{item.message}} \u003c/li\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ items:[ {message:'狂神说java'}, {message:'狂神说vue'}, {message:'狂神说js'} ] } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:4:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"5.双向绑定 \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{message}}\u003cbr\u003e \u003cinput type=\"password\" v-model=\"message\"\u003e\u003c/input\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:5:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"6.计算属性 \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{currentTime1()}}\u003cbr\u003e {{currentTime2}}\u003cbr\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" }, methods:{ currentTime1:function () { return Date.now() } }, computed:{ currentTime2:function () { return Date.now() } } }) \u003c/script\u003e \u003c/body\u003e 调用方式不同。computed直接以对象属性方式调用，不需要加括号，而methods必须要函数执行才可以得到结果。 绑定方式不同。methods与compute纯get方式都是单向绑定，不可以更改输入框中的值。compute的get与set方式是真正的双向绑定。 是否存在缓存。methods没有缓存，调用相同的值计算还是会重新计算。competed有缓存，在值不变的情况下不会再次计算，而是直接使用缓存中的值。 ","date":"2022-01-05","objectID":"/vue-study/:6:0","tags":["前端","js"],"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"什么是SpringMVC？ ","date":"2021-12-28","objectID":"/springmvc-study/:1:0","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"1、简介 很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。 SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringMVC也是要简化我们日常Web开发。 ","date":"2021-12-28","objectID":"/springmvc-study/:1:1","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"2、MVC设计模式 MVC设计模式的任务是将包含业务数据的模块与显示模块的视图解耦。这是怎样发生的？在模型和视图之间引入重定向层可以解决问题。此重定向层是控制器，控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。 Model（模型）： View（视图）： Controller（控制器）： ","date":"2021-12-28","objectID":"/springmvc-study/:1:2","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"3、初识SpringMVC 第一步、配置web.xml \u003c!-- 注册DispatcherServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!-- 关联一个springmvc配置文件--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spirngmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 设置启动级别--\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e· \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e 第二步、配置spirngmvc-servlet.xml \u003cbean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/\u003e \u003cbean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/\u003e \u003c!-- 视图解析器:DispatcherServlet给他的ModeLAndVIew--\u003e \u003c!-- 1.获取了ModelAndView的数据--\u003e \u003c!-- 2.解析ModelAndView的试图名字--\u003e \u003c!-- 3.拼接试图名字，找到对应视图--\u003e \u003c!-- 4.将数据渲染到视图上--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前置--\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003c!-- 后缀--\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e\u003c!-- Handler--\u003e \u003cbean id=\"/hello\" class=\"com.seawave.HelloController\"/\u003e \u003c/beans\u003e 第三步、在Controller类中测试 @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { // modelAndView 模型和视图 ModelAndView mv = new ModelAndView(); // 封装对象，放在ModelAndView中 mv.addObject(\"msg\",\"helloSpringMVC\"); // 封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); return mv; } } 结果：在浏览器中显示hellospringmvc。 ","date":"2021-12-28","objectID":"/springmvc-study/:1:3","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"SpringMVC的使用 ","date":"2021-12-28","objectID":"/springmvc-study/:2:0","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"1、使用注解开发SpringMVC 步骤1 ：配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!-- 注册DispatcherServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!-- 关联一个springmvc配置文件--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spirngmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 设置启动级别--\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e tips：此文件除非特殊需求无需变动 步骤2：配置springmvc-servlet \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003ccontext:component-scan base-package=\"com.seawave.controller\"/\u003e \u003cmvc:default-servlet-handler/\u003e \u003cmvc:annotation-driven/\u003e \u003c!-- 视图解析器:DispatcherServlet给他的ModeLAndVIew--\u003e \u003c!-- 1.获取了ModelAndView的数据--\u003e \u003c!-- 2.解析ModelAndView的试图名字--\u003e \u003c!-- 3.拼接试图名字，找到对应视图--\u003e \u003c!-- 4.将数据渲染到视图上--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前置--\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003c!-- 后缀--\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e \u003c/beans\u003e tips:此文件除特殊需求无需变动 步骤3：创建控制器 @Controller @RequestMapping(\"/test\") //非必须 public class HelloController { @RequestMapping(\"/hello\") //真实地址：项目路径/test/hello public String hello(Model model){ model.addAttribute(\"msg\",\"Hello,SpringMVCAnnotation!\"); return \"hello\"; //会被视图解析器处理 } } 此时在浏览器中访问http://localhost:8080/test/hello可以看到后端返回了：Hello,SpringMVCAnnotation! ","date":"2021-12-28","objectID":"/springmvc-study/:2:1","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"2、Restful风格 传统风格与Restful风格对比： 传统：http://baidu.com?search=china Restful：http://baidu.com/china 使用Restful风格可以使同一个url提交不同请求。 示例代码： @Controller public class RestFulController { 方式1：@RequestMapping(value = \"/add/{a}/{b}\",method = RequestMethod.GET) 方式2：@GetMapping(\"/add/{a}/{b}\") public String test1(@PathVariable int a, @PathVariable int b, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 当我们在浏览器中输入http://localhost:8080/add/1/2时，可以得到结果：3 从示例代码中可以看到我们指定了提交方式为GET，我们也可以通过注解的方式直接限定提交方式： @GetMapping @POSTMapping @DELETEMapping ….. ","date":"2021-12-28","objectID":"/springmvc-study/:2:2","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"3、获取请求参数 接收为普通参数 使用springmvc获取前端请求的参数时，只需要在控制器上设置相应的传参即可。 public class Controller { @RequestMapping(\"/add\") public String test1(int a, int b, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 默认情况下，形参类型和请求参数的名称一致，比如当我访问http://localhost:8080/add?a=1\u0026b=2时，那么a变量和b变量便会自动赋值1 和2，当形参名和请求参数名不一致时，我们可以添加@RequestParam 注解使之匹配： public class Controller { @RequestMapping(\"/add\") public String test1(@RequestParam(\"a\") int num1,@RequestParam(\"b\") int num, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 此时请求参数ab的值将会赋值到num1和num2. 接收为实体类 我们可以直接在控制器的形参中添加一个实体类，当前端发送请求时会自动创建该类的实体对象，会自动匹配属性名进行赋值： @RequestMapping(\"/test2\") public String test2( User user){ System.out.println(user); return \"test\"; } 此时我们访问http://localhost:8080/test2?name=zs\u0026id=11\u0026age=21时会创建一个name=zs，id=11，age=21的User对象。 控制台输出如下： User(id=11, name=zs, age=21) 注：请求参数名必须和实体类属性名一致，否则为null ","date":"2021-12-28","objectID":"/springmvc-study/:2:3","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"4、设置编码方式 前后端传递数据时，经常会遇到编码问题，比如中文乱码。springMVC为我们提供了一个现成的过滤器，我们直接在web.xml中配置即可。 \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2021-12-28","objectID":"/springmvc-study/:2:4","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"5、SpringMVC返回数据 大多数情况下，后端所要做的事仅仅是向前端返回数据，这意味着我们并不需要使用到视图解析器返回视图，我们可以给控制器的方法添加@ResponseBody注解来表示此处理器只返回数据。 例子： @Controller public class UserController { @RequestMapping(value = \"/j1\") @ResponseBody //使此控制器不会走视图解析器，直接返回字符串 public String json1(){ String str=\"\"; User user =new User(\"海浪\",20,\"男\"); ObjectMapper mapper=new ObjectMapper(); try { str = mapper.writeValueAsString(user); } catch (JsonProcessingException e) { e.printStackTrace(); } return str; } } 此控制器会返回一个user类的JSON字符串。 我们也可以在控制器类上使用@RestController来表明此控制器下的所有控制器均只返回数据。 ","date":"2021-12-28","objectID":"/springmvc-study/:2:5","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"6、解决SpringMVC返回JSON乱码问题 \u003cbean id=\"utf8Charset\" class=\"java.nio.charset.Charset\" factory-method=\"forName\"\u003e \u003cconstructor-arg value=\"UTF-8\" /\u003e \u003c/bean\u003e \u003cmvc:annotation-driven\u003e \u003cmvc:message-converters register-defaults=\"true\"\u003e \u003cbean class=\"org.springframework.http.converter.StringHttpMessageConverter\"\u003e \u003cconstructor-arg value=\"UTF-8\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"\u003e \u003cproperty name=\"objectMapper\"\u003e \u003cbean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"\u003e \u003cproperty name=\"failOnEmptyBeans\" value=\"false\"/\u003e \u003c/bean\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/mvc:message-converters\u003e \u003c/mvc:annotation-driven\u003e ","date":"2021-12-28","objectID":"/springmvc-study/:2:6","tags":["spring","java"],"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"什么是Spring？ ","date":"2021-12-17","objectID":"/spring-study/:1:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1、简介 Spring框架是由于软件开发 的复杂性而创建的。Spring使用的是基本的JavaBean 来完成以前只可能由EJB 完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ","date":"2021-12-17","objectID":"/spring-study/:1:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2、创始人 Rod在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位。更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。有着相当丰富的C/C++技术背景的Rod早在1996年就开始了对Java服务器端技术的研究。他是一个在保险、电子商务和金融行业有着丰富经验的技术顾问，同时也是JSR-154（Servlet 2.4）和JDO 2.0的规范专家、JCP的积极成员。 真正引起了人们的注意的，是在2002年Rod Johnson根据多年经验撰写的《Expert o-ne-on-One J2EE Design and Development》。其中对正统J2EE架构的臃肿、低效的质疑，引发了人们对正统J2EE的反思。这本书也体现了Rod Johnson对技术的态度，技术的选择应该基于实证或是自身的经验，而不是任何形式的偶像崇拜或者门户之见。正是这本书真正地改变了Java世界。基于这本书的代码，Rod Johnson创建了轻量级的容器Spring。Spring的出现，使得正统J2EE架构一统天下的局面被打破。基于Struts+Hibernate+Spring的J2EE架构也逐渐得到人们的认可，甚至在大型的项目架构中也逐渐开始应用。 ","date":"2021-12-17","objectID":"/spring-study/:1:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"3、官网 首页：https://spring.io 下载地址：https://repo1.maven.org/maven2/org/springframework/spring github：https://github.com/spring-projects/spring-framework maven： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e \u003c!--MyBatis整合--\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-17","objectID":"/spring-study/:1:3","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"4.IOC理论 public void setUserDao(UserDao userDao) { this.userDao = userDao; } 使用set来把决定权交给用户，降低系统耦合性。 ","date":"2021-12-17","objectID":"/spring-study/:1:4","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"Spring的使用 ","date":"2021-12-17","objectID":"/spring-study/:2:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.HelloSpring 例子： Dao接口 public interface UserDao { void getUser(); } 实现接口1： public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\"默认获取用户数据\"); } } 实现接口2： public class UserDaoMysqlImpl implements UserDao{ @Override public void getUser() { System.out.println(\"默认获取MYSQL数据\"); } } 业务层： public class UserServiceImpl implements UserService{ private UserDao userDao; @Override public void getUser() { userDao.getUser(); } public void setUserDao(UserDao userDao) { this.userDao = userDao; } } 通过spring实例化： public class MyTest { public static void main(String[] args) { //拿到spring容器 ApplicationContext beans = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) beans.getBean(\"UserServiceImpl\"); userServiceImpl.getUser(); } } 配置文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userImpl\" class=\"com.seawave.dao.UserDaoImpl\"/\u003e \u003cbean id=\"mysqlImpl\" class=\"com.seawave.dao.UserDaoMysqlImpl\"/\u003e \u003cbean id=\"UserServiceImpl\" class=\"com.seawave.service.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"userImpl\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.ioc创建对象的方式 默认使用无参构造 假设我们需要用有参构造创建对象： 方式一：通过下标赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"12\"/\u003e \u003cconstructor-arg index=\"1\" value=\"fuck\"/\u003e \u003c/bean\u003e 方式二：通过属性名赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"id\" value=\"12\"/\u003e \u003cconstructor-arg name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 在配置文件加载的时候，容器中管理的对象就已经初始化了！ ","date":"2021-12-17","objectID":"/spring-study/:2:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"3.Spring配置 3.1、别名 通过别名获取对象 \u003c!-- 别名，可以用过别名获取对象--\u003e \u003calias name=\"user\" alias=\"UserTese\"/\u003e 3.2、bean \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" name=\"userTest\"\u003e \u003c/bean\u003e id:bean对象的唯一标识符，相当于对象名 class：bean对应的全限定名，包名+类型 name：也是别名,可以取多个 3.3、import 用于团队开发，导入其他的bean配置文件，将多个配置文件合并为一个。 \u003cimport resource=\"beans.xml\"/\u003e \u003cimport resource=\"bean1.xml\"/\u003e \u003cimport resource=\"bean2.xml\"/\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:3","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"4.依赖注入 4.1、构造器注入 前面用到的方式即为构造器注入 4.2 Set方式注入【重点】 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器注入 【环境搭建】 1.复杂类型 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 2.真实测试对象 @Data public class Student { private String name; private Address address; private String[]books; private List\u003cString\u003e hobbies; private Map\u003cString,String\u003ecard; private Set\u003cString\u003egames; private Properties info; private String wife; } 复杂类型注入： \u003c!-- 第二种，Bean注入，ref--\u003e \u003cbean id=\"address\" class=\"com.seawave.pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"北京东城\"/\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"com.seawave.pojo.Student\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"address\" ref=\"address\"/\u003e 数组注入： \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e List集合注入: \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e map注入： \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"身份证\" value=\"330629197010232241\"/\u003e \u003centry key=\"银行卡\" value=\"340629197010232231\"/\u003e \u003c/map\u003e \u003c/property\u003e set注入： \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003eLOL\u003c/value\u003e \u003cvalue\u003eCOC\u003c/value\u003e \u003cvalue\u003eBOB\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e null值注入： \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e Properties注入： \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"url\"\u003ehttps://baidu.com\u003c/prop\u003e \u003cprop key=\"username\"\u003eseawave\u003c/prop\u003e \u003cprop key=\"password\"\u003ezgq123\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:4","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"5.bean的作用域 作用域 描述 singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。 request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。 session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 单例模式（默认模式） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"singleton\"\u003e 原型模式（每次从容器中获取都会产生一个新对象） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"prototype\"\u003e 其余的request、session、application、websocket 这些只能在web开发中失效 ","date":"2021-12-17","objectID":"/spring-study/:2:5","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"6.Bean自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性！ 在spring中有三种装配方式： 在xml中显示的配置 在java中显示配置 隐式 的自动装配bean【重要】 测试源代码： 此处的cat和dog是一个复杂类型 \u003cbean id=\"cat\" class=\"com.seawave.pojo.Cat\u003e \u003cproperty name=\"name\" value=\"xiaomiao\"/\u003e \u003c/bean\u003e \u003cbean id=\"dog\" class=\"com.seawave.pojo.Cat\u003e \u003cproperty name=\"name\" value=\"xiaowang\"/\u003e \u003c/bean\u003e 普通写法： \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"cat\" ref=\"cat\"/\u003e \u003cproperty name=\"dog\" ref=\"dog\"/\u003e \u003c/bean\u003e ByName自动装配 会自动在容器上下文中查找和自己对象set方法后面的值对应的beanID，无需手动装配cat和dog类 \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e ByType自动装配 会自动在容器上下文中查找和自己对象属性类型相同的beanID，同理 \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 使用注解进行自动装配 要使用注解须知： 导入约束：context约束 配置注解支持 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e @Autowired：直接在属性名上使用 @nonull：如果标记了这个注解，说明这个属性可以为null。 @required：如果显式定义了此属性，说明这个对象可以为null，否则不允许为空。 ","date":"2021-12-17","objectID":"/spring-study/:2:6","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"7.使用Java的方式配置Spring //这个注解表示这个类被Spring接管。 @Configuration public class MyConfig { //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean public User getUser() { return new User(); } } @Configuration @Data public class User { @Value(\"fuck\") private String name; } ","date":"2021-12-17","objectID":"/spring-study/:2:7","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"代理模式 为什么要学习代理模式？因为这就是SprngAOP的底层！ 代理模式的分类： 静态代理 动态代理 ","date":"2021-12-17","objectID":"/spring-study/:3:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.静态代理 角色分析： 抽象角色：一般会使用接口或者抽象类来解决。 真是角色：被代理的角色。 代理介绍：代理真实角色，代理之后一般会进行附属操作。 客户：访问代理对象的人。 代码步骤： 接口 //租房 public interface Rent { public void rent(); } 真实角色 //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\"房东要出租房子\"); } } 代理角色 package com.seawave.demo01; public class Proxy { private Host host; public Proxy(){ } public Proxy(Host host){ this.host=host; } public void rent(){ seeHouse(); sign(); host.rent(); } public void seeHouse(){ System.out.println(\"中介带你看房\"); } public void sign(){ System.out.println(\"签合同\"); } } 客户访问代理角色 package com.seawave.demo01; public class Client { public static void main(String[] args) { Host host=new Host(); host.rent(); } } 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共业务。 公共业务交给代理角色！实现了业务分工。 公共业务发生扩展的时候，方便管理！ 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍。 ","date":"2021-12-17","objectID":"/spring-study/:3:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.动态代理 动态代理和静态代理角色一样。 动态代理的代理类是动态生成的，不是我们写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理。 package com.seawave.demo03; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用这个类动态生产代理类 public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Object target; //传入被代理的实体类 public void setTarget(Object target) { this.target = target; } public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result =method.invoke(target,args); return result; } public void log(String msg){ System.out.println(\"执行了\"+msg+\"方法\"); } } public class Client { public static void main(String[] args) { ProxyInvocationHandler pih = new ProxyInvocationHandler(); Host host = new Host(); pih.setTarget(host); Rent rent= (Rent) pih.getProxy(); rent.rent(); } } ","date":"2021-12-17","objectID":"/spring-study/:3:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"AOP ","date":"2021-12-17","objectID":"/spring-study/:4:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程 ，通过预编译 方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP 的延续，是软件开发中的一个热点，也是Spring 框架中的一个重要内容，是函数式编程 的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度 降低，提高程序的可重用性，同时提高了开发的效率。 ","date":"2021-12-17","objectID":"/spring-study/:4:1","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.使用Spring实现AOP 使用aop织入需要导入依赖包： \u003cdependency\u003e \u003cgroupId\u003eorg.apache.geronimo.bundles\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.6.8_2\u003c/version\u003e \u003c/dependency\u003e 方式一：使用Spring的API接口 例子： 第一步、配置如下spring配置文件： \u003cbean id=\"userService\" class=\"com.seawave.service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"com.seawave.log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.seawave.log.AfterLog\"/\u003e \u003c!--配置aop--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"poincut\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003c!-- 执行环绕--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"poincut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"poincut\"/\u003e \u003c/aop:config\u003e 第二步、创建如下两个log日志类 public class Log implements MethodBeforeAdvice { @Override //method:要执行的目标对象的方法 //objects：参数 //target//目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } public class AfterLog implements AfterReturningAdvice { @Override //returnValue:返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"返回结果为：\"+returnValue); } } 第三步、在测试类中执行方法 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); } } 运行结果如下 com.seawave.service.UserServiceImpl的add被执行了 增加了一个用户 执行了add返回结果为：null 由此可见，我们通过context.getBean方法从spring容器中得到了一个UserService的代理类，我们可以在执行UserService类的方法之前插入自己的逻辑方法。 方式二：使用自定义类 例子 第一步、新建diy类 public class DiyPointCut { public void before() { System.out.println(\"===========方法执行前==========\"); } public void after() { System.out.println(\"===========方法执行后===========\"); } 第二步、配置spring配置文件 //注册diy类 \u003cbean id=\"diy\" class=\"com.seawave.diy.DiyPointCut\"/\u003e \u003c!--方式二--\u003e \u003caop:config\u003e \u003caop:aspect ref=\"diy\"\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e 第三步、在测试类中测试，代码和第一种一样 我们可以得到如下结果： ===========方法执行前========== 增加了一个用户 ===========方法执行后=========== ","date":"2021-12-17","objectID":"/spring-study/:4:2","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"整合MyBatis 实际开发中，我们通常会使用多哥框架技术，这就需要将mybatis和spring进行整合。 例子 配置数据源和工厂注入 \u003c!-- 一些基本配置 --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/bean\u003e \u003c!--创建sqlsession工厂--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--此配置项用于连接原有的mabatis配置文件，因此mybatis配置文件仍可使用。--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:com/seawave/mapper/UserMapper.xml\"/\u003e \u003c/bean\u003e \u003cbean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"\u003e \u003c!-- 只能使用构造器注入sqlSessionFactory--\u003e \u003cconstructor-arg index=\"0\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e 我们可以看到： 我们将原有的mybatis配置文件通过注入的方式放到了spring的配置文件中。 上述配置项都是一些固定的配置。 创建接口实现类 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u003cUser\u003e getUsers() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUsers(); } 注意 setSqlSession方法必不可少，缺少会导致spring无法注入。 注入实现类 \u003cbean id=\"userMapper\" class=\"com.seawave.mapper.UserMapperImpl\"\u003e \u003cproperty name=\"sqlSession\" ref=\"sqlSession\"/\u003e \u003c/bean\u003e 测试 public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-dao.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } ","date":"2021-12-17","objectID":"/spring-study/:5:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"Spring事务 事务是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为原子性、一致性、隔离性和持久性 (ACID) 属性，只有这样才能成为一个事务。事务一般都是与数据库打交道的操作。 简单来说，事务就是将一系列要做的事情放在一起，要么一起成功，要么一起失败。 spring提供了以下两种事务： 声明式事务 编程式事务 本文将举例声明式事务。 例子： 在UserMapper中配置如下sql语句： \u003cmapper namespace=\"com.seawave.mapper.UserMapper\"\u003e \u003cselect id=\"getUsers\" resultType=\"user\"\u003e select * from user \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"user\"\u003e insert into user (id,name) values (#{id} , #{name}); \u003c/insert\u003e \u003cdelete id=\"delete\" parameterType=\"user\"\u003e deletes from user where id=#{id}; \u003c/delete\u003e \u003c/mapper\u003e 可以看到，我们故意将delete写错成deletes，以此来模仿业务逻辑中的错误。 配置spring配置文件： \u003c!-- 配置声明式事务--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003c!-- 结合APO实现事务的织入--\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"\u003e \u003c!-- 给哪些方法配置事务--\u003e \u003ctx:attributes\u003e \u003ctx:method name=\"getUsers\"/\u003e \u003ctx:method name=\"insertUser\"/\u003e \u003ctx:method name=\"deleteUser\"/\u003e \u003c!-- 配置事务的传播特性--\u003e \u003ctx:method name=\"select\" read-only=\"true\"/\u003e \u003c/tx:attributes\u003e \u003c/tx:advice\u003e \u003c!-- 配置事务切入--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"txPointCut\" expression=\"execution(* com.seawave.mapper.*.* (..))\"/\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/\u003e \u003c/aop:config\u003e 测试： public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } 此时运行程序会提示sql语句错误，但是并没有执行insertUser中的插入语句，如果我们注释掉第二步中的语句，那么将会产生插入成功，删除失败的现象。而此时对于插入和删除这两个操作来说，他们是一致的，其中一个失败另外一个也不会执行。 ","date":"2021-12-17","objectID":"/spring-study/:6:0","tags":["spring","java"],"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"什么是MyBatis？ ","date":"2021-12-05","objectID":"/mybatis-study/:1:0","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"1.MyBatis介绍 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免 了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注 解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对 象)映射成数据库中的记录。 ","date":"2021-12-05","objectID":"/mybatis-study/:1:1","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"2.如何获取MyBatis有关的信息？ MyBatis官方文档：https://mybatis.org/mybatis-3 MyBatis项目地址：https://github.com/mybatis/mybatis-3 Maven中央仓库：https://mvnrepository.com ","date":"2021-12-05","objectID":"/mybatis-study/:1:2","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"MyBatis的安装 ","date":"2021-12-05","objectID":"/mybatis-study/:2:0","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"方式一：在idea中配置MyBatis 首先创建一个maven项目，然后在pom.xml中添加依赖列表： \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:2:1","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"方式二：手动导入jar包 点击此处 在github上下载jar包，解压后放入导入idea项目即可 ","date":"2021-12-05","objectID":"/mybatis-study/:2:2","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"MyBatis的使用（idea+maven） ","date":"2021-12-05","objectID":"/mybatis-study/:3:0","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"1.在你的资源目录创建mybatis-config.xml配置文件（构建 SqlSessionFactory） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"org/mybatis/example/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 其中需要注意的是： driver项的值需要改为具体的数据库驱动全类名。 url，username，password需要根据实际情况进行更改。 mapper中resource指向sql语句列表，这一项后面会提及。 ","date":"2021-12-05","objectID":"/mybatis-study/:3:1","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"2.从 SqlSessionFactory 中获取 SqlSession //创建工厂 String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //从工厂中获取sqlSession try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); } ","date":"2021-12-05","objectID":"/mybatis-study/:3:2","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"3.SQL语句映射 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"org.mybatis.example.BlogMapper\"\u003e \u003cselect id=\"selectBlog\" resultType=\"Blog\"\u003e select * from Blog where id = #{id} \u003c/select\u003e \u003c/mapper\u003e 在上述代码中我们需要更改以下几项： namespace:他指向你所需要映射的java接口 id:映射方法的名称 resultType指明返回类型 不可或缺的是，我们需要更改查询语句。 ","date":"2021-12-05","objectID":"/mybatis-study/:3:3","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"4.ResultMap结果集映射 当数据库字段名和属性名不一致时，会导致实体类中的属性值为null，例子如下： //实体类的属性如下： class user{ int name; int password; } //接口方法 void getUser(); \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" type=com.example.User\u003e select * name,pwd from users \u003c/select\u003e 此时返回的User类中的password属性值为null，对于这个问题我们可以在mapper配置文件中添加resultMap标签来解决。 \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" resultmap=com.example.User\u003e select * name,pwd from users \u003c/select\u003e \u003c!--新增resultMap标签--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column表示数据库中的字段，property表示实体类中的属性 --\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:4","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"5.多对一的处理 在实际查询数据库的过程中，大概率会遇到多对一的情况，比如多个学生对应一个老师，我们查询寻学生时需要连同老师一起查询，这时我们需要对结果集做一些修改。 例子： //实体类的属性如下： class Student{ int id; String name; Teacher teacher } //接口方法 void getStudent(); 很明显 以上User类中的Teacher属性是一个复杂类型，所以我们需要单独处理。 方法一 类似于子查询的方法 \u003cselect id = \"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student \u003c/select\u003e \u003cresultMap id =\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" colum=\"id\"/\u003e \u003cresult property=\"name\"colum=\"name\"/\u003e \u003c!-- 复杂的属性，单独处理。对象：association 集合：collection --\u003e \u003cassociation property=\"teacher\" colum=\"tid\" javaType=\"Teacher\" select=\"getTcher\"/\u003e \u003c!--单独查询Teacher的语句--\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id=#{id} \u003c/select\u003e \u003c/result\u003e 方法二 按照结果嵌套处理 \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type =\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:5","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"6. 一对多的处理 与多对一相反,我们会遇到一对多的情况,比如说一个老师对应多个老师,所以我们同样需要对结果集进行处理. 例子: //实体类 public class Teacher{ private int id; private String name; private List\u003cStudent\u003e students; } //接口方法 class TeacherMapper{ Teacher getTeacher(int id); } \u003cselect id=\"getTeacher\" resultMapper=\"\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id and t.id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type =\"Teacher\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003ccollection property=\"teacher\" TypeOf=\"Stident\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:6","tags":["spring","spring boot","java","mybatis"],"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["各种笔记"],"content":"Markdown简介 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 来自：百度百科 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:1:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"一、Markdown标题 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.使用 = 和 - 标记 我展示的是一级标题 ================= 我展示的是二级标题 显示效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.使用#号标记 用#号标记标题时要注意#号与标题文本中间的空格 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ####### 六级标题 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"二、Markdown段落 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.段落分段 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.字体格式 Markdown可以使用如下字体格式： 斜体文本 —文字首末分别使用一*包围文本 斜体文本 —文字首末分别使用一个_包围文本 粗体文本 —文字首末分别使用两个*包围文本 粗体文本 —文字首末分别使用两个_包围文本 删除文本 —文字首末分别使用两个~包围文本 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"3.分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ----- 显示效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:3","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"4. 下划线 下划线可以通过 HTML 的 标签来实现： \u003cu\u003e带下划线的文本\u003c/u\u003e 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:4","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"5.脚注 创建脚注格式类似这样 [^1]。 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:5","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"三、Markdown列表 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.无序列表 无序列表使用星号()、加号(+)或是减号(-*)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.有序列表 有序列表使用数字标记，后面同样需要加一个空格在填写内容： 1. 第一项 2. 第二项 3. 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"3.列表嵌套 列表是可以嵌套的，达到分级效果。 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:3","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"四、Markdown区块 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.普通区块 Markdown 区块引用是在段落开头使用 \u003e 符号 ，然后后面紧跟一个空格符号： \u003e Markdown \u003e 我们都有一个家 \u003e 名字叫中国 效果如下: ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.区块嵌套 区块是可以嵌套的，一个 \u003e 符号是最外层，两个 \u003e 符号是第一层嵌套，以此类推： \u003e 最外层 \u003e \u003e 第一层嵌套 \u003e \u003e \u003e 第二层嵌套 区块也可以和列表互相嵌套： * 第一项 \u003e 区块列表 \u003e 区块列表的嵌套 * 第二项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"五、Markdown 代码 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.代码片段 如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如： `System.out.println(Markdown)` 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.代码区块 代码区块用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： ```javascript $(document).ready(function () { alert('RUNOOB'); }); ​``` 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"六、Markdown 链接 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.超链接 链接使用方法如下： 欢迎来到我的博客 [点击进入](https://seawave.top) 效果如下： 欢迎来到我的博客 点击进入 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:1","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.高级链接 我们可以通过变量来设置一个链接，变量赋值在文档末尾进行： 此方法可以使用在需要大量引用同一网址的文档中。 点击进入 [Google][1] 点击进入 [seawave][2] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [2]: http://www.seawave.com/ 效果如下： 点击进入 Google 点击进入 seawave 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:2","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"七、Markdown 图片 Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \"可选标题\") 使用举例： ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png) ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png \"100years\") 效果如下: 100yearsBaidu 图标 \" 100years 当然，你也可以像网址那样对图片网址使用变量: 这个链接用 1 作为网址变量 [Gitee][1]. 然后在文档的结尾为变量赋值（网址） [1]: https://gitee.com/static/images/logo-black.svg 效果如下： 这个链接用 1 作为网址变量 Gitee . 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown-basics-guide/:8:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"八、Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 实例如下： | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:9:0","tags":["markdown"],"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["Windows小技巧"],"content":"SakuraFrp简介 SakuraFrp是目前市面上少有的免费内网穿透平台，可以用于个人搭建服务器和做一些应用的流量穿透。花生壳虽然也有免费的，但是带宽和流量都有很大限制，SakuraFrp免费用户就可提供10Mbps和6GB的流量相比之下这个平台算是比较良心的了。 点此处进入Sakura官网 ","date":"2021-01-12","objectID":"/remote-desktop/:1:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接端和被链接端准备 这里我们以win10 20H2版本做演示 1.按WIN+R打开运行窗口 2.在运行窗口输入 SystemPropertiesRemote 3.在远程协助中勾选 允许远程协助链接这台计算机 在远程桌面中选择 允许远程连接到此计算机 4.确定。到此配置完毕。 ","date":"2021-01-12","objectID":"/remote-desktop/:2:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"创建SakuraFrp隧道 1.注册账号 2.创建隧道： 节点最好是选国内的，联通还是电信根据你自己的网络环境来选。 隧道名称随意，取一个你自己能分辨的就行 隧道类型 选TCP 本地地址填127.0.0.1 本地端口填3389（windows远程连接的端口号） 远程端口留空即可 4.单击确认创建，完成创建。 ","date":"2021-01-12","objectID":"/remote-desktop/:3:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接隧道 1.下载Sakura客户端。单击下载 无法下载可以在主页点击软件下载手动选择windows客户端。 2.打开客户端并登录 （可以选择开机自启这样每次开机会自动连接到隧道） 3.点击隧道，可以看到我们刚刚创建的隧道。 4.点击启动开关启动隧道，这样你的电脑就成功连接到了sakura服务器。电脑右下角会给出一个通知，提示连接方式。 来不及保存的话可以点击软件左侧的日志选项，里面会写出你连接到你电脑所需的IP和端口号。 5.保存所提示的IP或域名，选择其中一种即可。 ","date":"2021-01-12","objectID":"/remote-desktop/:4:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"在其他电脑上连接到你的电脑 1.打开远程连接工具。 第1种方法：win+r打开运行窗口，输入mstsc。 第2种方法：单击开始菜单，在附件中找到远程桌面连接。 2.输入你的ip:端口。 3.完成你的连接。 ","date":"2021-01-12","objectID":"/remote-desktop/:5:0","tags":["windows","frp"],"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":null,"content":"关于我 目前还只是个在学习的小白罢了，不值一提。 ","date":"2020-12-04","objectID":"/about/:0:1","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于我的博客 记录一些笔记 都是一些基础的东西，大佬勿看 偶尔会更新一些计算机方面的技巧 ","date":"2020-12-04","objectID":"/about/:0:2","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于我的理想 现阶段学好后端 长远向全栈努力吧 emmmmm成为一个大佬 ","date":"2020-12-04","objectID":"/about/:0:3","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于此站点 此站点由Hugo 强力驱动 主题：LoveIt ","date":"2020-12-04","objectID":"/about/:0:4","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"欢迎来到Seawave的博客 ","date":"2020-12-03","objectID":"/my-first-post/:0:1","tags":null,"title":"My First Blog","uri":"/my-first-post/"}]