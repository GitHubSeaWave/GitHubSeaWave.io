[{"categories":["学习笔记"],"content":"Vue快速入门 以下所有代码均可在浏览器直接运行，替换body即可。为了节省空间，里的内容需自行添加。 ","date":"2022-01-05","objectID":"/vue-study/:0:0","tags":null,"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"1.导入Vue \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\"\u003e\u003c/script\u003e ","date":"2022-01-05","objectID":"/vue-study/:1:0","tags":null,"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"2.数据绑定 方式一： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{message}} \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"hello,vue!\" } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 方式二： 通过v-bind指令： \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cspan v-bind:title=\"message\"\u003e悬停几秒查看动态绑定\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" } }) \u003c/script\u003e \u003c/body\u003e 经过以上的操作div中的{{message}}的显示内容已经被绑定到了VUE对象中的message属性上，更改message的值即可动态刷新页面中的值。 ","date":"2022-01-05","objectID":"/vue-study/:2:0","tags":null,"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"3.条件判断 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1 v-if=\"ok==='a'\"\u003eA\u003c/h1\u003e \u003ch1 v-else-if=\"ok==='b'\"\u003eB\u003c/h1\u003e \u003ch1 v-else\u003eC\u003c/h1\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ ok:'a' } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:3:0","tags":null,"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"4.语句循环 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cli v-for=\"item in items\"\u003e {{item.message}} \u003c/li\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ items:[ {message:'狂神说java'}, {message:'狂神说vue'}, {message:'狂神说js'} ] } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:4:0","tags":null,"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"5.双向绑定 \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{message}}\u003cbr\u003e \u003cinput type=\"password\" v-model=\"message\"\u003e\u003c/input\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2022-01-05","objectID":"/vue-study/:5:0","tags":null,"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"6.计算属性 \u003cbody\u003e \u003cdiv id=\"app\"\u003e {{currentTime1()}}\u003cbr\u003e {{currentTime2}}\u003cbr\u003e \u003c/div\u003e \u003cscript\u003e var vm =new Vue({ el:\"#app\", data:{ message:\"\" }, methods:{ currentTime1:function () { return Date.now() } }, computed:{ currentTime2:function () { return Date.now() } } }) \u003c/script\u003e \u003c/body\u003e 调用方式不同。computed直接以对象属性方式调用，不需要加括号，而methods必须要函数执行才可以得到结果。 绑定方式不同。methods与compute纯get方式都是单向绑定，不可以更改输入框中的值。compute的get与set方式是真正的双向绑定。 是否存在缓存。methods没有缓存，调用相同的值计算还是会重新计算。competed有缓存，在值不变的情况下不会再次计算，而是直接使用缓存中的值。 ","date":"2022-01-05","objectID":"/vue-study/:6:0","tags":null,"title":"Vue快速入门","uri":"/vue-study/"},{"categories":["学习笔记"],"content":"什么是SpringMVC？ ","date":"2021-12-28","objectID":"/springmvc-study/:1:0","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"1、简介 很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。 SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringMVC也是要简化我们日常Web开发。 ","date":"2021-12-28","objectID":"/springmvc-study/:1:1","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"2、MVC设计模式 MVC设计模式的任务是将包含业务数据的模块与显示模块的视图解耦。这是怎样发生的？在模型和视图之间引入重定向层可以解决问题。此重定向层是控制器，控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。 Model（模型）： View（视图）： Controller（控制器）： ","date":"2021-12-28","objectID":"/springmvc-study/:1:2","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"3、初识SpringMVC 第一步、配置web.xml \u003c!-- 注册DispatcherServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!-- 关联一个springmvc配置文件--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spirngmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 设置启动级别--\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e· \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e 第二步、配置spirngmvc-servlet.xml \u003cbean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/\u003e \u003cbean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/\u003e \u003c!-- 视图解析器:DispatcherServlet给他的ModeLAndVIew--\u003e \u003c!-- 1.获取了ModelAndView的数据--\u003e \u003c!-- 2.解析ModelAndView的试图名字--\u003e \u003c!-- 3.拼接试图名字，找到对应视图--\u003e \u003c!-- 4.将数据渲染到视图上--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前置--\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003c!-- 后缀--\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e\u003c!-- Handler--\u003e \u003cbean id=\"/hello\" class=\"com.seawave.HelloController\"/\u003e \u003c/beans\u003e 第三步、在Controller类中测试 @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { // modelAndView 模型和视图 ModelAndView mv = new ModelAndView(); // 封装对象，放在ModelAndView中 mv.addObject(\"msg\",\"helloSpringMVC\"); // 封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); return mv; } } 结果：在浏览器中显示hellospringmvc。 ","date":"2021-12-28","objectID":"/springmvc-study/:1:3","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"SpringMVC的使用 ","date":"2021-12-28","objectID":"/springmvc-study/:2:0","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"1、使用注解开发SpringMVC 步骤1 ：配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!-- 注册DispatcherServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!-- 关联一个springmvc配置文件--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spirngmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 设置启动级别--\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringmvc\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e tips：此文件除非特殊需求无需变动 步骤2：配置springmvc-servlet \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003ccontext:component-scan base-package=\"com.seawave.controller\"/\u003e \u003cmvc:default-servlet-handler/\u003e \u003cmvc:annotation-driven/\u003e \u003c!-- 视图解析器:DispatcherServlet给他的ModeLAndVIew--\u003e \u003c!-- 1.获取了ModelAndView的数据--\u003e \u003c!-- 2.解析ModelAndView的试图名字--\u003e \u003c!-- 3.拼接试图名字，找到对应视图--\u003e \u003c!-- 4.将数据渲染到视图上--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前置--\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003c!-- 后缀--\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e \u003c/beans\u003e tips:此文件除特殊需求无需变动 步骤3：创建控制器 @Controller @RequestMapping(\"/test\") //非必须 public class HelloController { @RequestMapping(\"/hello\") //真实地址：项目路径/test/hello public String hello(Model model){ model.addAttribute(\"msg\",\"Hello,SpringMVCAnnotation!\"); return \"hello\"; //会被视图解析器处理 } } 此时在浏览器中访问http://localhost:8080/test/hello可以看到后端返回了：Hello,SpringMVCAnnotation! ","date":"2021-12-28","objectID":"/springmvc-study/:2:1","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"2、Restful风格 传统风格与Restful风格对比： 传统：http://baidu.com?search=china Restful：http://baidu.com/china 使用Restful风格可以使同一个url提交不同请求。 示例代码： @Controller public class RestFulController { 方式1：@RequestMapping(value = \"/add/{a}/{b}\",method = RequestMethod.GET) 方式2：@GetMapping(\"/add/{a}/{b}\") public String test1(@PathVariable int a, @PathVariable int b, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 当我们在浏览器中输入http://localhost:8080/add/1/2时，可以得到结果：3 从示例代码中可以看到我们指定了提交方式为GET，我们也可以通过注解的方式直接限定提交方式： @GetMapping @POSTMapping @DELETEMapping ….. ","date":"2021-12-28","objectID":"/springmvc-study/:2:2","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"3、获取请求参数 接收为普通参数 使用springmvc获取前端请求的参数时，只需要在控制器上设置相应的传参即可。 public class Controller { @RequestMapping(\"/add\") public String test1(int a, int b, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 默认情况下，形参类型和请求参数的名称一致，比如当我访问http://localhost:8080/add?a=1\u0026b=2时，那么a变量和b变量便会自动赋值1 和2，当形参名和请求参数名不一致时，我们可以添加@RequestParam 注解使之匹配： public class Controller { @RequestMapping(\"/add\") public String test1(@RequestParam(\"a\") int num1,@RequestParam(\"b\") int num, Model mv){ mv.addAttribute(\"msg\",a+b); return \"test\"; } } 此时请求参数ab的值将会赋值到num1和num2. 接收为实体类 我们可以直接在控制器的形参中添加一个实体类，当前端发送请求时会自动创建该类的实体对象，会自动匹配属性名进行赋值： @RequestMapping(\"/test2\") public String test2( User user){ System.out.println(user); return \"test\"; } 此时我们访问http://localhost:8080/test2?name=zs\u0026id=11\u0026age=21时会创建一个name=zs，id=11，age=21的User对象。 控制台输出如下： User(id=11, name=zs, age=21) 注：请求参数名必须和实体类属性名一致，否则为null ","date":"2021-12-28","objectID":"/springmvc-study/:2:3","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"4、设置编码方式 前后端传递数据时，经常会遇到编码问题，比如中文乱码。springMVC为我们提供了一个现成的过滤器，我们直接在web.xml中配置即可。 \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2021-12-28","objectID":"/springmvc-study/:2:4","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"5、SpringMVC返回数据 大多数情况下，后端所要做的事仅仅是向前端返回数据，这意味着我们并不需要使用到视图解析器返回视图，我们可以给控制器的方法添加@ResponseBody注解来表示此处理器只返回数据。 例子： @Controller public class UserController { @RequestMapping(value = \"/j1\") @ResponseBody //使此控制器不会走视图解析器，直接返回字符串 public String json1(){ String str=\"\"; User user =new User(\"海浪\",20,\"男\"); ObjectMapper mapper=new ObjectMapper(); try { str = mapper.writeValueAsString(user); } catch (JsonProcessingException e) { e.printStackTrace(); } return str; } } 此控制器会返回一个user类的JSON字符串。 我们也可以在控制器类上使用@RestController来表明此控制器下的所有控制器均只返回数据。 ","date":"2021-12-28","objectID":"/springmvc-study/:2:5","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"6、解决SpringMVC返回JSON乱码问题 \u003cbean id=\"utf8Charset\" class=\"java.nio.charset.Charset\" factory-method=\"forName\"\u003e \u003cconstructor-arg value=\"UTF-8\" /\u003e \u003c/bean\u003e \u003cmvc:annotation-driven\u003e \u003cmvc:message-converters register-defaults=\"true\"\u003e \u003cbean class=\"org.springframework.http.converter.StringHttpMessageConverter\"\u003e \u003cconstructor-arg value=\"UTF-8\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"\u003e \u003cproperty name=\"objectMapper\"\u003e \u003cbean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"\u003e \u003cproperty name=\"failOnEmptyBeans\" value=\"false\"/\u003e \u003c/bean\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/mvc:message-converters\u003e \u003c/mvc:annotation-driven\u003e ","date":"2021-12-28","objectID":"/springmvc-study/:2:6","tags":null,"title":"初识SpringMVC","uri":"/springmvc-study/"},{"categories":["学习笔记"],"content":"什么是Spring？ ","date":"2021-12-17","objectID":"/spring-study/:1:0","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1、简介 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ","date":"2021-12-17","objectID":"/spring-study/:1:1","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2、创始人 Rod在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位。更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。有着相当丰富的C/C++技术背景的Rod早在1996年就开始了对Java服务器端技术的研究。他是一个在保险、电子商务和金融行业有着丰富经验的技术顾问，同时也是JSR-154（Servlet 2.4）和JDO 2.0的规范专家、JCP的积极成员。 真正引起了人们的注意的，是在2002年Rod Johnson根据多年经验撰写的《Expert o-ne-on-One J2EE Design and Development》。其中对正统J2EE架构的臃肿、低效的质疑，引发了人们对正统J2EE的反思。这本书也体现了Rod Johnson对技术的态度，技术的选择应该基于实证或是自身的经验，而不是任何形式的偶像崇拜或者门户之见。正是这本书真正地改变了Java世界。基于这本书的代码，Rod Johnson创建了轻量级的容器Spring。Spring的出现，使得正统J2EE架构一统天下的局面被打破。基于Struts+Hibernate+Spring的J2EE架构也逐渐得到人们的认可，甚至在大型的项目架构中也逐渐开始应用。 ","date":"2021-12-17","objectID":"/spring-study/:1:2","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"3、官网 首页：https://spring.io 下载地址：https://repo1.maven.org/maven2/org/springframework/spring github：https://github.com/spring-projects/spring-framework maven： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e \u003c!--MyBatis整合--\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.13\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-17","objectID":"/spring-study/:1:3","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"4.IOC理论 public void setUserDao(UserDao userDao) { this.userDao = userDao; } 使用set来把决定权交给用户，降低系统耦合性。 ","date":"2021-12-17","objectID":"/spring-study/:1:4","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"Spring的使用 ","date":"2021-12-17","objectID":"/spring-study/:2:0","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.HelloSpring 例子： Dao接口 public interface UserDao { void getUser(); } 实现接口1： public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\"默认获取用户数据\"); } } 实现接口2： public class UserDaoMysqlImpl implements UserDao{ @Override public void getUser() { System.out.println(\"默认获取MYSQL数据\"); } } 业务层： public class UserServiceImpl implements UserService{ private UserDao userDao; @Override public void getUser() { userDao.getUser(); } public void setUserDao(UserDao userDao) { this.userDao = userDao; } } 通过spring实例化： public class MyTest { public static void main(String[] args) { //拿到spring容器 ApplicationContext beans = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) beans.getBean(\"UserServiceImpl\"); userServiceImpl.getUser(); } } 配置文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userImpl\" class=\"com.seawave.dao.UserDaoImpl\"/\u003e \u003cbean id=\"mysqlImpl\" class=\"com.seawave.dao.UserDaoMysqlImpl\"/\u003e \u003cbean id=\"UserServiceImpl\" class=\"com.seawave.service.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"userImpl\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:1","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.ioc创建对象的方式 默认使用无参构造 假设我们需要用有参构造创建对象： 方式一：通过下标赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"12\"/\u003e \u003cconstructor-arg index=\"1\" value=\"fuck\"/\u003e \u003c/bean\u003e 方式二：通过属性名赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"id\" value=\"12\"/\u003e \u003cconstructor-arg name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 在配置文件加载的时候，容器中管理的对象就已经初始化了！ ","date":"2021-12-17","objectID":"/spring-study/:2:2","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"3.Spring配置 3.1、别名 通过别名获取对象 \u003c!-- 别名，可以用过别名获取对象--\u003e \u003calias name=\"user\" alias=\"UserTese\"/\u003e 3.2、bean \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" name=\"userTest\"\u003e \u003c/bean\u003e id:bean对象的唯一标识符，相当于对象名 class：bean对应的全限定名，包名+类型 name：也是别名,可以取多个 3.3、import 用于团队开发，导入其他的bean配置文件，将多个配置文件合并为一个。 \u003cimport resource=\"beans.xml\"/\u003e \u003cimport resource=\"bean1.xml\"/\u003e \u003cimport resource=\"bean2.xml\"/\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:3","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"4.依赖注入 4.1、构造器注入 前面用到的方式即为构造器注入 4.2 Set方式注入【重点】 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器注入 【环境搭建】 1.复杂类型 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 2.真实测试对象 @Data public class Student { private String name; private Address address; private String[]books; private List\u003cString\u003e hobbies; private Map\u003cString,String\u003ecard; private Set\u003cString\u003egames; private Properties info; private String wife; } 复杂类型注入： \u003c!-- 第二种，Bean注入，ref--\u003e \u003cbean id=\"address\" class=\"com.seawave.pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"北京东城\"/\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"com.seawave.pojo.Student\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"address\" ref=\"address\"/\u003e 数组注入： \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e List集合注入: \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e map注入： \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"身份证\" value=\"330629197010232241\"/\u003e \u003centry key=\"银行卡\" value=\"340629197010232231\"/\u003e \u003c/map\u003e \u003c/property\u003e set注入： \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003eLOL\u003c/value\u003e \u003cvalue\u003eCOC\u003c/value\u003e \u003cvalue\u003eBOB\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e null值注入： \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e Properties注入： \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"url\"\u003ehttps://baidu.com\u003c/prop\u003e \u003cprop key=\"username\"\u003eseawave\u003c/prop\u003e \u003cprop key=\"password\"\u003ezgq123\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e ","date":"2021-12-17","objectID":"/spring-study/:2:4","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"5.bean的作用域 作用域 描述 singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。 request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。 session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 单例模式（默认模式） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"singleton\"\u003e 原型模式（每次从容器中获取都会产生一个新对象） \u003cbean id=\"user\" class=\"com.seawave.pojo.User\" scope=\"prototype\"\u003e 其余的request、session、application、websocket 这些只能在web开发中失效 ","date":"2021-12-17","objectID":"/spring-study/:2:5","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"6.Bean自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性！ 在spring中有三种装配方式： 在xml中显示的配置 在java中显示配置 隐式 的自动装配bean【重要】 测试源代码： 此处的cat和dog是一个复杂类型 \u003cbean id=\"cat\" class=\"com.seawave.pojo.Cat\u003e \u003cproperty name=\"name\" value=\"xiaomiao\"/\u003e \u003c/bean\u003e \u003cbean id=\"dog\" class=\"com.seawave.pojo.Cat\u003e \u003cproperty name=\"name\" value=\"xiaowang\"/\u003e \u003c/bean\u003e 普通写法： \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003cproperty name=\"cat\" ref=\"cat\"/\u003e \u003cproperty name=\"dog\" ref=\"dog\"/\u003e \u003c/bean\u003e ByName自动装配 会自动在容器上下文中查找和自己对象set方法后面的值对应的beanID，无需手动装配cat和dog类 \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e ByType自动装配 会自动在容器上下文中查找和自己对象属性类型相同的beanID，同理 \u003cbean id=\"people\" class=\"com.seawave.pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"fuck\"/\u003e \u003c/bean\u003e 使用注解进行自动装配 要使用注解须知： 导入约束：context约束 配置注解支持 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e @Autowired：直接在属性名上使用 @nonull：如果标记了这个注解，说明这个属性可以为null。 @required：如果显式定义了此属性，说明这个对象可以为null，否则不允许为空。 ","date":"2021-12-17","objectID":"/spring-study/:2:6","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"7.使用Java的方式配置Spring //这个注解表示这个类被Spring接管。 @Configuration public class MyConfig { //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean public User getUser() { return new User(); } } @Configuration @Data public class User { @Value(\"fuck\") private String name; } ","date":"2021-12-17","objectID":"/spring-study/:2:7","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"代理模式 为什么要学习代理模式？因为这就是SprngAOP的底层！ 代理模式的分类： 静态代理 动态代理 ","date":"2021-12-17","objectID":"/spring-study/:3:0","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.静态代理 角色分析： 抽象角色：一般会使用接口或者抽象类来解决。 真是角色：被代理的角色。 代理介绍：代理真实角色，代理之后一般会进行附属操作。 客户：访问代理对象的人。 代码步骤： 接口 //租房 public interface Rent { public void rent(); } 真实角色 //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\"房东要出租房子\"); } } 代理角色 package com.seawave.demo01; public class Proxy { private Host host; public Proxy(){ } public Proxy(Host host){ this.host=host; } public void rent(){ seeHouse(); sign(); host.rent(); } public void seeHouse(){ System.out.println(\"中介带你看房\"); } public void sign(){ System.out.println(\"签合同\"); } } 客户访问代理角色 package com.seawave.demo01; public class Client { public static void main(String[] args) { Host host=new Host(); host.rent(); } } 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共业务。 公共业务交给代理角色！实现了业务分工。 公共业务发生扩展的时候，方便管理！ 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍。 ","date":"2021-12-17","objectID":"/spring-study/:3:1","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.动态代理 动态代理和静态代理角色一样。 动态代理的代理类是动态生成的，不是我们写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理。 package com.seawave.demo03; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //使用这个类动态生产代理类 public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Object target; //传入被代理的实体类 public void setTarget(Object target) { this.target = target; } public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result =method.invoke(target,args); return result; } public void log(String msg){ System.out.println(\"执行了\"+msg+\"方法\"); } } public class Client { public static void main(String[] args) { ProxyInvocationHandler pih = new ProxyInvocationHandler(); Host host = new Host(); pih.setTarget(host); Rent rent= (Rent) pih.getProxy(); rent.rent(); } } ","date":"2021-12-17","objectID":"/spring-study/:3:2","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"AOP ","date":"2021-12-17","objectID":"/spring-study/:4:0","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"1.什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 ","date":"2021-12-17","objectID":"/spring-study/:4:1","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"2.使用Spring实现AOP 使用aop织入需要导入依赖包： \u003cdependency\u003e \u003cgroupId\u003eorg.apache.geronimo.bundles\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.6.8_2\u003c/version\u003e \u003c/dependency\u003e 方式一：使用Spring的API接口 例子： 第一步、配置如下spring配置文件： \u003cbean id=\"userService\" class=\"com.seawave.service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"com.seawave.log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.seawave.log.AfterLog\"/\u003e \u003c!--配置aop--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"poincut\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003c!-- 执行环绕--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"poincut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"poincut\"/\u003e \u003c/aop:config\u003e 第二步、创建如下两个log日志类 public class Log implements MethodBeforeAdvice { @Override //method:要执行的目标对象的方法 //objects：参数 //target//目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } public class AfterLog implements AfterReturningAdvice { @Override //returnValue:返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"返回结果为：\"+returnValue); } } 第三步、在测试类中执行方法 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); } } 运行结果如下 com.seawave.service.UserServiceImpl的add被执行了 增加了一个用户 执行了add返回结果为：null 由此可见，我们通过context.getBean方法从spring容器中得到了一个UserService的代理类，我们可以在执行UserService类的方法之前插入自己的逻辑方法。 方式二：使用自定义类 例子 第一步、新建diy类 public class DiyPointCut { public void before() { System.out.println(\"===========方法执行前==========\"); } public void after() { System.out.println(\"===========方法执行后===========\"); } 第二步、配置spring配置文件 //注册diy类 \u003cbean id=\"diy\" class=\"com.seawave.diy.DiyPointCut\"/\u003e \u003c!--方式二--\u003e \u003caop:config\u003e \u003caop:aspect ref=\"diy\"\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* com.seawave.service.UserServiceImpl.* (..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e 第三步、在测试类中测试，代码和第一种一样 我们可以得到如下结果： ===========方法执行前========== 增加了一个用户 ===========方法执行后=========== ","date":"2021-12-17","objectID":"/spring-study/:4:2","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"整合MyBatis 实际开发中，我们通常会使用多哥框架技术，这就需要将mybatis和spring进行整合。 例子 配置数据源和工厂注入 \u003c!-- 一些基本配置 --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/bean\u003e \u003c!--创建sqlsession工厂--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--此配置项用于连接原有的mabatis配置文件，因此mybatis配置文件仍可使用。--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:com/seawave/mapper/UserMapper.xml\"/\u003e \u003c/bean\u003e \u003cbean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"\u003e \u003c!-- 只能使用构造器注入sqlSessionFactory--\u003e \u003cconstructor-arg index=\"0\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e 我们可以看到： 我们将原有的mybatis配置文件通过注入的方式放到了spring的配置文件中。 上述配置项都是一些固定的配置。 创建接口实现类 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u003cUser\u003e getUsers() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUsers(); } 注意 setSqlSession方法必不可少，缺少会导致spring无法注入。 注入实现类 \u003cbean id=\"userMapper\" class=\"com.seawave.mapper.UserMapperImpl\"\u003e \u003cproperty name=\"sqlSession\" ref=\"sqlSession\"/\u003e \u003c/bean\u003e 测试 public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-dao.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } ","date":"2021-12-17","objectID":"/spring-study/:5:0","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"Spring事务 事务是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为原子性、一致性、隔离性和持久性 (ACID) 属性，只有这样才能成为一个事务。事务一般都是与数据库打交道的操作。 简单来说，事务就是将一系列要做的事情放在一起，要么一起成功，要么一起失败。 spring提供了以下两种事务： 声明式事务 编程式事务 本文将举例声明式事务。 例子： 在UserMapper中配置如下sql语句： \u003cmapper namespace=\"com.seawave.mapper.UserMapper\"\u003e \u003cselect id=\"getUsers\" resultType=\"user\"\u003e select * from user \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"user\"\u003e insert into user (id,name) values (#{id} , #{name}); \u003c/insert\u003e \u003cdelete id=\"delete\" parameterType=\"user\"\u003e deletes from user where id=#{id}; \u003c/delete\u003e \u003c/mapper\u003e 可以看到，我们故意将delete写错成deletes，以此来模仿业务逻辑中的错误。 配置spring配置文件： \u003c!-- 配置声明式事务--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003c!-- 结合APO实现事务的织入--\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"\u003e \u003c!-- 给哪些方法配置事务--\u003e \u003ctx:attributes\u003e \u003ctx:method name=\"getUsers\"/\u003e \u003ctx:method name=\"insertUser\"/\u003e \u003ctx:method name=\"deleteUser\"/\u003e \u003c!-- 配置事务的传播特性--\u003e \u003ctx:method name=\"select\" read-only=\"true\"/\u003e \u003c/tx:attributes\u003e \u003c/tx:advice\u003e \u003c!-- 配置事务切入--\u003e \u003caop:config\u003e \u003caop:pointcut id=\"txPointCut\" expression=\"execution(* com.seawave.mapper.*.* (..))\"/\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/\u003e \u003c/aop:config\u003e 测试： public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.getUsers()) { System.out.println(user); } } } 此时运行程序会提示sql语句错误，但是并没有执行insertUser中的插入语句，如果我们注释掉第二步中的语句，那么将会产生插入成功，删除失败的现象。而此时对于插入和删除这两个操作来说，他们是一致的，其中一个失败另外一个也不会执行。 ","date":"2021-12-17","objectID":"/spring-study/:6:0","tags":null,"title":"初识Spring5","uri":"/spring-study/"},{"categories":["学习笔记"],"content":"·什么是MyBatis？ ","date":"2021-12-05","objectID":"/mybatis-study/:1:0","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"1.MyBatis介绍 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免 了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注 解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对 象)映射成数据库中的记录。 ","date":"2021-12-05","objectID":"/mybatis-study/:1:1","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"2.如何获取MyBatis有关的信息？ MyBatis官方文档：https://mybatis.org/mybatis-3 MyBatis项目地址：https://github.com/mybatis/mybatis-3 Maven中央仓库：https://mvnrepository.com ","date":"2021-12-05","objectID":"/mybatis-study/:1:2","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"MyBatis的安装 ","date":"2021-12-05","objectID":"/mybatis-study/:2:0","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"方式一：在idea中配置MyBatis 首先创建一个maven项目，然后在pom.xml中添加依赖列表： \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:2:1","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"方式二：手动导入jar包 点击此处在github上下载jar包，解压后放入导入idea项目即可 ","date":"2021-12-05","objectID":"/mybatis-study/:2:2","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"MyBatis的使用（idea+maven） ","date":"2021-12-05","objectID":"/mybatis-study/:3:0","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"1.在你的资源目录创建mybatis-config.xml配置文件（构建 SqlSessionFactory） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"org/mybatis/example/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 其中需要注意的是： driver项的值需要改为具体的数据库驱动全类名。 url，username，password需要根据实际情况进行更改。 mapper中resource指向sql语句列表，这一项后面会提及。 ","date":"2021-12-05","objectID":"/mybatis-study/:3:1","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"2.从 SqlSessionFactory 中获取 SqlSession //创建工厂 String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //从工厂中获取sqlSession try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); } ","date":"2021-12-05","objectID":"/mybatis-study/:3:2","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"3.SQL语句映射 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"org.mybatis.example.BlogMapper\"\u003e \u003cselect id=\"selectBlog\" resultType=\"Blog\"\u003e select * from Blog where id = #{id} \u003c/select\u003e \u003c/mapper\u003e 在上述代码中我们需要更改以下几项： namespace:他指向你所需要映射的java接口 id:映射方法的名称 resultType指明返回类型 不可或缺的是，我们需要更改查询语句。 ","date":"2021-12-05","objectID":"/mybatis-study/:3:3","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"4.ResultMap结果集映射 当数据库字段名和属性名不一致时，会导致实体类中的属性值为null，例子如下： //实体类的属性如下： class user{ int name; int password; } //接口方法 void getUser(); \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" type=com.example.User\u003e select * name,pwd from users \u003c/select\u003e 此时返回的User类中的password属性值为null，对于这个问题我们可以在mapper配置文件中添加resultMap标签来解决。 \u003c!--mapper中的查询语句如下--\u003e \u003cselect id=\"getUser\" resultmap=com.example.User\u003e select * name,pwd from users \u003c/select\u003e \u003c!--新增resultMap标签--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column表示数据库中的字段，property表示实体类中的属性 --\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:4","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"5.多对一的处理 在实际查询数据库的过程中，大概率会遇到多对一的情况，比如多个学生对应一个老师，我们查询寻学生时需要连同老师一起查询，这时我们需要对结果集做一些修改。 例子： //实体类的属性如下： class Student{ int id; String name; Teacher teacher } //接口方法 void getStudent(); 很明显 以上User类中的Teacher属性是一个复杂类型，所以我们需要单独处理。 方法一 类似于子查询的方法 \u003cselect id = \"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student \u003c/select\u003e \u003cresultMap id =\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" colum=\"id\"/\u003e \u003cresult property=\"name\"colum=\"name\"/\u003e \u003c!-- 复杂的属性，单独处理。对象：association 集合：collection --\u003e \u003cassociation property=\"teacher\" colum=\"tid\" javaType=\"Teacher\" select=\"getTcher\"/\u003e \u003c!--单独查询Teacher的语句--\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id=#{id} \u003c/select\u003e \u003c/result\u003e 方法二 按照结果嵌套处理 \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type =\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:5","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["学习笔记"],"content":"6. 一对多的处理 与多对一相反,我们会遇到一对多的情况,比如说一个老师对应多个老师,所以我们同样需要对结果集进行处理. 例子: //实体类 public class Teacher{ private int id; private String name; private List\u003cStudent\u003e students; } //接口方法 class TeacherMapper{ Teacher getTeacher(int id); } \u003cselect id=\"getTeacher\" resultMapper=\"\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id and t.id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type =\"Teacher\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003ccollection property=\"teacher\" TypeOf=\"Stident\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2021-12-05","objectID":"/mybatis-study/:3:6","tags":null,"title":"MyBatis使用教程","uri":"/mybatis-study/"},{"categories":["各种笔记"],"content":"Markdown简介 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 来自：百度百科 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:1:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"一、Markdown标题 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.使用 = 和 - 标记 我展示的是一级标题 ================= 我展示的是二级标题 显示效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.使用#号标记 用#号标记标题时要注意#号与标题文本中间的空格 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ####### 六级标题 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:2:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"二、Markdown段落 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.段落分段 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.字体格式 Markdown可以使用如下字体格式： 斜体文本 —文字首末分别使用一*包围文本 斜体文本 —文字首末分别使用一个_包围文本 粗体文本 —文字首末分别使用两个*包围文本 粗体文本 —文字首末分别使用两个_包围文本 删除文本 —文字首末分别使用两个~包围文本 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"3.分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ----- 显示效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:3","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"4. 下划线 下划线可以通过 HTML 的 标签来实现： \u003cu\u003e带下划线的文本\u003c/u\u003e 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:4","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"5.脚注 创建脚注格式类似这样 [^1]。 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:3:5","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"三、Markdown列表 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.无序列表 无序列表使用星号()、加号(+)或是减号(-*)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.有序列表 有序列表使用数字标记，后面同样需要加一个空格在填写内容： 1. 第一项 2. 第二项 3. 第三项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"3.列表嵌套 列表是可以嵌套的，达到分级效果。 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:4:3","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"四、Markdown区块 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.普通区块 Markdown 区块引用是在段落开头使用 \u003e 符号 ，然后后面紧跟一个空格符号： \u003e Markdown \u003e 我们都有一个家 \u003e 名字叫中国 效果如下: ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.区块嵌套 区块是可以嵌套的，一个 \u003e 符号是最外层，两个 \u003e 符号是第一层嵌套，以此类推： \u003e 最外层 \u003e \u003e 第一层嵌套 \u003e \u003e \u003e 第二层嵌套 区块也可以和列表互相嵌套： * 第一项 \u003e 区块列表 \u003e 区块列表的嵌套 * 第二项 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:5:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"五、Markdown 代码 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.代码片段 如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如： `System.out.println(Markdown)` 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.代码区块 代码区块用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： ​```javascript $(document).ready(function () { alert('RUNOOB'); }); ​``` 效果如下： ","date":"2021-07-02","objectID":"/markdown-basics-guide/:6:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"六、Markdown 链接 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"1.超链接 链接使用方法如下： 欢迎来到我的博客 [点击进入](https://seawave.top) 效果如下： 欢迎来到我的博客 点击进入 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:1","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"2.高级链接 我们可以通过变量来设置一个链接，变量赋值在文档末尾进行： 此方法可以使用在需要大量引用同一网址的文档中。 点击进入 [Google][1] 点击进入 [seawave][2] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [2]: http://www.seawave.com/ 效果如下： 点击进入 Google 点击进入 seawave 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown-basics-guide/:7:2","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"七、Markdown 图片 Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \"可选标题\") 使用举例： ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png) ![Baidu 图标](https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png \"100years\") 效果如下: 100yearsBaidu 图标 \"\r100years\r 当然，你也可以像网址那样对图片网址使用变量: 这个链接用 1 作为网址变量 [Gitee][1]. 然后在文档的结尾为变量赋值（网址） [1]: https://gitee.com/static/images/logo-black.svg 效果如下： 这个链接用 1 作为网址变量 Gitee. 然后在文档的结尾为变量赋值（网址） ","date":"2021-07-02","objectID":"/markdown-basics-guide/:8:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["各种笔记"],"content":"八、Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 实例如下： | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 ","date":"2021-07-02","objectID":"/markdown-basics-guide/:9:0","tags":null,"title":"MarkDown基础语法指北","uri":"/markdown-basics-guide/"},{"categories":["Windows小技巧"],"content":"SakuraFrp简介 SakuraFrp是目前市面上少有的免费内网穿透平台，可以用于个人搭建服务器和做一些应用的流量穿透。花生壳虽然也有免费的，但是带宽和流量都有很大限制，SakuraFrp免费用户就可提供10Mbps和6GB的流量相比之下这个平台算是比较良心的了。 点此处进入Sakura官网 ","date":"2021-01-12","objectID":"/remote-desktop/:1:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接端和被链接端准备 这里我们以win10 20H2版本做演示 1.按WIN+R打开运行窗口 2.在运行窗口输入 SystemPropertiesRemote 3.在远程协助中勾选 允许远程协助链接这台计算机 在远程桌面中选择 允许远程连接到此计算机 4.确定。到此配置完毕。 ","date":"2021-01-12","objectID":"/remote-desktop/:2:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"创建SakuraFrp隧道 1.注册账号 2.创建隧道： 节点最好是选国内的，联通还是电信根据你自己的网络环境来选。 隧道名称随意，取一个你自己能分辨的就行 隧道类型 选TCP 本地地址填127.0.0.1 本地端口填3389（windows远程连接的端口号） 远程端口留空即可 4.单击确认创建，完成创建。 ","date":"2021-01-12","objectID":"/remote-desktop/:3:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"连接隧道 1.下载Sakura客户端。单击下载 无法下载可以在主页点击软件下载手动选择windows客户端。 2.打开客户端并登录 （可以选择开机自启这样每次开机会自动连接到隧道） 3.点击隧道，可以看到我们刚刚创建的隧道。 4.点击启动开关启动隧道，这样你的电脑就成功连接到了sakura服务器。电脑右下角会给出一个通知，提示连接方式。 来不及保存的话可以点击软件左侧的日志选项，里面会写出你连接到你电脑所需的IP和端口号。 5.保存所提示的IP或域名，选择其中一种即可。 ","date":"2021-01-12","objectID":"/remote-desktop/:4:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":["Windows小技巧"],"content":"在其他电脑上连接到你的电脑 1.打开远程连接工具。 第1种方法：win+r打开运行窗口，输入mstsc。 第2种方法：单击开始菜单，在附件中找到远程桌面连接。 2.输入你的ip:端口。 3.完成你的连接。 ","date":"2021-01-12","objectID":"/remote-desktop/:5:0","tags":null,"title":"通过SakuraFrp进行远程桌面连接","uri":"/remote-desktop/"},{"categories":null,"content":"关于我 目前还只是个在学习的小白罢了，不值一提。 ","date":"2020-12-04","objectID":"/about/:0:1","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于我的博客 记录一些笔记 都是一些基础的东西，大佬勿看 偶尔会更新一些计算机方面的技巧 ","date":"2020-12-04","objectID":"/about/:0:2","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于我的理想 现阶段学好后端 长远向全栈努力吧 emmmmm成为一个大佬 ","date":"2020-12-04","objectID":"/about/:0:3","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"关于此站点 此站点由Hugo强力驱动 主题：LoveIt ","date":"2020-12-04","objectID":"/about/:0:4","tags":null,"title":"关于SeaWave","uri":"/about/"},{"categories":null,"content":"欢迎来到Seawave的博客 ","date":"2020-12-03","objectID":"/my-first-post/:0:1","tags":null,"title":"My First Blog","uri":"/my-first-post/"}]